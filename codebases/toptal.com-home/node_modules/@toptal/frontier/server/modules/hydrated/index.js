import {
    mapValues
} from 'lodash'

// eslint-disable-next-line
import {
    shouldHydrateComponent
} from '~/frontier.config'

import isBrowser from '../../../lib/is-browser'

import {
    hydrate
} from './client'
import {
    withProps
} from './server'

const DEFAULT_OPTIONS = {
    /**
     * Hydrate components only when visible
     * via window.IntersectionObserver (if supported).
     */
    defer: true,
    /**
     * Schedule hydration to next "idle" CPU time
     * via window.requestIdleCallback (if supported).
     */
    atIdle: false
}

/**
 * Hydrates Component on the client with the options
 * or renders it on the server alongside its props.
 *
 * @param {React.Component} Component
 * @param {object} options
 * @param {boolean} defer
 * @param {boolean} atIdle
 * @param {string} scope
 * @param {number} id
 */
function hydrated(Component, {
    defer,
    atIdle
}, scope, id) {
    const hydrationId = `${scope}-${id}`
    const shouldHydrate = shouldHydrateComponent() && isBrowser()

    if (shouldHydrate) {
        return hydrate({
            Component,
            defer,
            atIdle
        }, hydrationId)
    }

    return withProps(Component, hydrationId)
}

/**
 * Returns a hydrated HOC with respect to the scope to maintain
 * server-side hydration ID consistency.
 *
 * TODO:
 * - make linting to enforce getHydrated calls only at top level
 * - try switching to automatic "scoping"
 *
 * @param {string} scope
 */
export function getHydrated(scope) {
    let id = 0
    return function(Component, options) {
        options = Object.assign({}, DEFAULT_OPTIONS, options)
        return hydrated(Component, options, scope, id++)
    }
}

/**
 * Returns a map of component names to hydrated component versions
 *
 * @param {string} scope
 * @param {object} components
 * @param {object} componentOptions
 */
export const getHydratedComponents = (
    scope,
    components,
    componentOptions = {}
) => {
    const hydrated = getHydrated(scope)

    return mapValues(components, (component, componentName) =>
        hydrated(
            component,
            Object.assign(
                component.hydrationOptions || {},
                componentOptions[componentName]
            )
        )
    )
}