require('intersection-observer')

/**
 * Invokes callback when target becomes visible.
 * Uses a new IntersectionObserver instance per target for simplicity.
 *
 * @param {HTMLElement} target
 * @param {function} callback
 */
function whenVisible(target, callback) {
    const PADDING = '50px'

    const observer = new window.IntersectionObserver(
        function(entries, observer) {
            if (entries[0].isIntersecting) {
                observer.disconnect()
                callback()
            }
        }, {
            rootMargin: PADDING
        }
    )
    observer.observe(target)
}

/**
 * Returns true if IntersectionObserver is supported.
 *
 * @returns {boolean}
 */
function whenVisibleSupported() {
    return typeof window.IntersectionObserver === 'function'
}

/**
 * Tries to postpone callback invocation until the next CPU idle.
 * The maximum delay is supposed to work as a capping setTimeout
 * when no idle time is available before.
 *
 * @param {function} callback
 */
function scheduleForIdle(callback) {
    const MAX_DELAY = 250
    if (typeof window.requestIdleCallback === 'function') {
        return window.requestIdleCallback(callback, {
            timeout: MAX_DELAY
        })
    }
    callback()
}

export {
    whenVisible,
    whenVisibleSupported,
    scheduleForIdle
}