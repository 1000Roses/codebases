import {
    actionChannel,
    call,
    cancel as cancelSaga,
    fork,
    takeEvery
} from 'redux-saga/effects';
import {
    buffers
} from 'redux-saga';

import {
    connect
} from 'react-redux';
import {
    shortId
} from './utils';

const SUPPLY = 'udacity/workspace/supply';
const CANCEL = 'udacity/workspace/cancel';

/*
  withReduxScope is a modified form of the connect function from react-redux.

  Requires: ownProps.scope, ownProps.selectState

  The scope refers to the location in the redux store
  where this workspace's instance will keep its state. Since
  there could be more than one on a page we need a routing layer to supply
  the correct slice of the redux store to this particular instance, as well
  as a cancel function to remove that slice when the workspace is cleaned up.

  SUPPLY will if provided start a saga to listen on the main event channel.
  CANCEL will cancel the saga and disconnect it from the event channel.
*/
export const withReduxScope = (
    mapStateToProps = (state) => state,
    mapDispatchToProps = () => ({}),
    mergeProps,
    opts
) => connect(
    (state, ownProps) => ({
        scopedState: getState(ownProps.selectState(state), ownProps.scope)
    }),
    (dispatch, ownProps) => {
        return {
            ...mapDispatchToProps(dispatch, ownProps),
            supply: (opts) =>
                dispatch(supply({
                    ...opts,
                    scope: ownProps.scope,
                    store: ownProps.store
                })),
            cancel: () => dispatch(cancel(ownProps.scope))
        };
    },
    mergeProps,
    opts
);

export function supply({
    saga,
    predicate,
    reducer,
    initialState,
    scope
}) {
    if (!scope) {
        scope = shortId();
    }
    if (!predicate) {
        predicate = () => true;
    }

    return {
        type: SUPPLY,
        scope,
        saga,
        reducer,
        initialState,
        predicate
    };
}

export function cancel(scope) {
    return {
        type: CANCEL,
        scope
    };
}

export function getState(state, scope) {
    return state[scope] && state[scope].state;
}


export const initialState = {};
/*
  Solely responsible for adding and removing scopes from the store.
  Any action to be handled by a target's reducer will be called and
  if the target exists, and the new state applied.
*/
function reducer(state = {}, action = {}) {
    const {
        initialState,
        scope,
        type,
        reducer
    } = action;
    if (type === SUPPLY) {
        if (!state[scope]) {
            return Object.assign({}, state, {
                [scope]: {
                    reducer: reducer || ((state) => state),
                    state: initialState || null
                }
            });
        } else {
            const newState = Object.assign({}, state[scope]);

            // Load new reducer
            if (reducer) {
                newState.reducer = reducer;
            }

            // Reset state
            if (initialState) {
                newState.state = initialState;
            }

            return Object.assign({}, state, {
                [scope]: Object.assign({}, state[scope], newState)
            });
        }
    } else if (type === CANCEL) {
        if (state[scope]) {
            const newState = Object.assign({}, state);
            delete newState[scope];
            return newState;
        } else {
            return state;
        }
    } else if (scope && state[scope]) {
        // Im not the reducer for this action, pass it on to the reducer
        // nested inside my state that matches the scope
        return Object.assign({},
            state, {
                [scope]: Object.assign({}, state[scope], {
                    state: state[scope].reducer(
                        state[scope].state,
                        action
                    )
                })
            });
    } else {
        return state;
    }
}

export default reducer;

export function* saga() {
    let running = {};

    function* closeTarget(target) {
        if (running[target]) {
            const {
                task,
                channels
            } = running[target];
            yield cancelSaga(task);
            for (const channel of channels) {
                yield call(() => channel.close());
            }
            delete running[target];
        }
    }

    yield takeEvery(SUPPLY, function*(supply) {
        if (!supply.saga) {
            throw new Error(
                `A component decorated withReduxScope tried to supply a saga but none was provided. The received keys were ${Object.keys(supply)}`
            );
        }
        // If we already have something under that target, restart it.
        yield call(closeTarget, supply.scope);

        const eventChannels = [];
        // Get a channel factory for this saga.
        const eventChannelFactory = function*() {
            const channel = yield actionChannel(
                (action) => action.scope && action.scope === supply.scope && supply.predicate(action),
                buffers.expanding(100)
            );

            eventChannels.push(channel);
            return channel;
        };

        running[supply.scope] = {
            task: yield fork(supply.saga, eventChannelFactory, supply.scope),
                channels: eventChannels
        };
    });

    yield takeEvery(CANCEL, function*({
        scope
    }) {
        yield call(closeTarget, scope);
    });
}