import _                  from 'lodash';
import React, {Component} from 'react';
import PropTypes          from 'prop-types';
import moment             from 'moment';

import Select             from '@udacity/ureact-select';
import {TextInput}        from '@udacity/ureact-components';

import DateField          from './date-field'

import {formTypes}        from '../constants/forms';

import {__}               from '../helpers/localization';
import ebanxFields        from './ebanx-billing-details-form-fields';
import formHelper         from '../helpers/form-helper';

import styles             from './ebanx-billing-details-form.module.scss';

export default class BillingDetailsForm extends Component {
  static propTypes = {
    onChange: PropTypes.func.isRequired,
    validateAllFields: PropTypes.bool,
    country: PropTypes.string,
    // Accept as props for autofill
    region: PropTypes.string,
    city: PropTypes.string,
    line1: PropTypes.string,
  }

  state = {
    fields: {
      ..._.mapValues(ebanxFields, (value, key) => _.get(this.props, key, '')),
    },
    validation: {
      ..._.mapValues(ebanxFields, () => true),
    },
    valid: false
  }

  componentDidMount() {
    if (this.props.validateAllFields) {
      this.validateAllFields();
    }
    this.props.onChange({
      fields: this.state.fields,
      valid: this.state.valid
    });
  }

  componentDidUpdate(prevProps) {
    if (this.props.validateAllFields && !prevProps.validateAllFields) {
      this.validateAllFields();
    } else if (!this.props.validateAllFields && prevProps.validateAllFields) {
      this.setState({
        validation: _.mapValues(this.state.validation, () => true)
      });
    }
  }

  buildFormFields() {
    const {fields, validation} = this.state;
    return _.mapValues(ebanxFields, (opts, key) => {
      if (typeof opts === 'function') {
        opts = opts(fields.country);
      }
      let Component = null;
      switch (opts.type) {
        case 'select':
          Component = Select;
          break;
        case 'date':
          Component = DateField;
          break;
        default:
          Component = TextInput;
          break;
      }

      const valid = validation[key];
      const options = {
        ...opts,
        name: key,
        className: formHelper.getClassName(valid, opts.type, styles),
        value: fields[key],
        onChange: (e) => this.handleFieldChange(key, e),
        onBlur: () => this.validateField(key)
      };

      delete options.errorMessage;

      if (key === 'region' || key === 'postalCode') {
        options.ref = (input) => { this[`${key}_ref`] = input; };
      } else if (key === 'birthDate') {
        options.onChange = this.handleBirthDateChange
      }

      return (
        <div className={styles[key]} key={key}>
          <Component {...options} />
          {!valid && opts.errorMessage &&
            <div className={styles.error_message}>
              {opts.errorMessage}
            </div>
          }
        </div>
      );
    });
  }

  validateAllFields() {
    const {fields} = this.state;
    const validation = _.mapValues(ebanxFields, (val, key) => {
      return formHelper.validateField(formTypes.ADDRESS, key, fields[key], fields.country);
    });
    this.setState({validation}, this.handleOnChange);
  }

  validateField = (key) => {
    const valid = formHelper.validateField(
      formTypes.ADDRESS,
      key,
      this.state.fields[key],
      this.state.fields.country
    );
    this.setState({
      validation: {
        ...this.state.validation,
        [key]: valid
      }
    }, this.handleOnChange);
  }

  handleFieldChange = (key, event) => {
    const value = event.value || event.target.value;
    const fields = {
      ...this.state.fields,
      [key]: value
    };

    // Reset the state value if country is updated
    if (key === 'country') {
      fields.state = '';
    }

    this.setState({fields}, () => {
      if (this.props.validateAllFields) {
        this.validateField(key);
      }
      // Focus on next input after dropdown selections
      if (key === 'country') {
        this.region_ref.focus();
      } else if (key === 'region') {
        this.postalCode_ref.focus();
      }
      this.handleOnChange();
    });
  }

  handleBirthDateChange = ({ birthDate, valid }) => {
    const { day, month, year } = birthDate;
    const isIncomplete = _.values(birthDate).some(_.isNull);
    const date = moment(new Date(year, month, day)).format('YYYY-MM-DD');
    const fields = {
      ...this.state.fields,
      birthDate: date
    };

    const validation = {
      ...this.state.validation,
      birthDate: valid || isIncomplete
    };

    this.setState({fields, validation}, this.handleOnChange);
  };

  handleOnChange = () => {
    const {fields} = this.state;
    const valid = formHelper.allFieldsValid(formTypes.ADDRESS, fields, fields.country);
    this.setState({valid}, () => this.props.onChange({fields, valid}));
  }

  render() {
    const formFields = this.buildFormFields();

    return (
      <div>
        <div className={styles.inputs_container}>
          <div className={styles.input_row}>
            {formFields.cpf}
            {formFields.phoneNumber}
          </div>

          <div className={styles.input_row}>
            {formFields.postalCode}
          </div>

          <div className={styles.input_row}>
            {formFields.line1}
          </div>

          <div className={styles.input_row}>
            {formFields.streetNumber}
            {formFields.line2}
          </div>

          <div className={styles.input_row}>
            {formFields.city}
            {formFields.region}
          </div>

          <div className={styles.subheader}>{__('Birthdate')}</div>
          <div className={styles.input_row}>
            {formFields.birthDate}
          </div>
        </div>
      </div>
    );
  }
}
