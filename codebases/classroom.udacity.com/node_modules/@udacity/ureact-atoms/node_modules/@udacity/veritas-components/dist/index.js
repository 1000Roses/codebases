'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

function _interopDefault(ex) {
    return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;
}

var React = require('react');
var React__default = _interopDefault(React);
var reactDom = require('react-dom');
var reactDom__default = _interopDefault(reactDom);
var PropTypes = _interopDefault(require('prop-types'));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}

function commonjsRequire() {
    throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var classnames = createCommonjsModule(function(module) {
    /*!
      Copyright (c) 2017 Jed Watson.
      Licensed under the MIT License (MIT), see
      http://jedwatson.github.io/classnames
    */
    /* global define */

    (function() {

        var hasOwn = {}.hasOwnProperty;

        function classNames() {
            var classes = [];

            for (var i = 0; i < arguments.length; i++) {
                var arg = arguments[i];
                if (!arg) continue;

                var argType = typeof arg;

                if (argType === 'string' || argType === 'number') {
                    classes.push(arg);
                } else if (Array.isArray(arg) && arg.length) {
                    var inner = classNames.apply(null, arg);
                    if (inner) {
                        classes.push(inner);
                    }
                } else if (argType === 'object') {
                    for (var key in arg) {
                        if (hasOwn.call(arg, key) && arg[key]) {
                            classes.push(key);
                        }
                    }
                }
            }

            return classes.join(' ');
        }

        if (module.exports) {
            classNames.default = classNames;
            module.exports = classNames;
        } else {
            window.classNames = classNames;
        }
    }());
});

var PREFIX = "vds-avatar";
/** Avatars are used to represent a person. It displays an image or initials. */

var Avatar = function(_a) {
    var _b = _a.borderColor,
        borderColor = _b === void 0 ? "none" : _b,
        _c = _a.hidden,
        hidden = _c === void 0 ? false : _c,
        image = _a.image,
        initials = _a.initials,
        name = _a.name,
        _d = _a.size,
        size = _d === void 0 ? "md" : _d;
    var className = classnames(PREFIX, borderColor !== "none" && PREFIX + "--" + borderColor, size && PREFIX + "--" + size);
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className,
        "aria-label": name,
        "aria-hidden": hidden
    }, image ? /*#__PURE__*/ React__default.createElement("img", {
        src: image,
        alt: name,
        title: name
    }) : /*#__PURE__*/ React__default.createElement("abbr", {
        title: name
    }, initials || name.charAt(0)));
};

/** VisuallyHidden hides elements on the interface but keeps them visible to screen readers. */

var VisuallyHidden = function(_a) {
    var children = _a.children;
    return /*#__PURE__*/ React__default.createElement("span", {
        className: "vds-visually-hidden"
    }, children);
};

/*
 * Converts language-agnostic "directions" (start, end, top, bottom) into "placements" Popper.js understands (left, right, bottom, top).
 * Handles RTL permutations by detecting if the `body` tag has `dir=rtl` set, since Popper.js computes position using JS, not CSS.
 *
 * https://github.com/FezVrasta/react-popper
 */

const useDirectionToPopperPlacement = direction => {
    const [convertedDirection, setConvertedDirection] = React.useState();
    const placement = {
        start: "left",
        end: "right"
    };
    const isRtl = getComputedStyle(document.body).direction === "rtl";
    React.useEffect(() => {
        if (direction === "start") {
            setConvertedDirection(isRtl ? placement.end : placement.start);
        } else if (direction === "end") {
            setConvertedDirection(isRtl ? placement.start : placement.end);
        } else {
            setConvertedDirection(direction);
        }
    });
    return convertedDirection;
};

/*
 * Provides onClickOutside event behavior for dismissable components like Modal and Popover.
 * Accepts a ref and an event handler, and calls the handler when elements outside the ref element are clicked.
 */

const useOnClickOutside = (ref, handler) => {
    const events = ["mousedown", "touchstart"];
    const handlerRef = React.useRef(handler);
    React.useEffect(() => {
        handlerRef.current = handler;
    });
    React.useEffect(() => {
        const listener = event => {
            if (!ref.current || !handlerRef.current || ref.current.contains(event.target)) {
                return;
            }

            handlerRef.current(event);
        };

        events.map(event => document.addEventListener(event, listener));
        return () => {
            events.map(event => document.removeEventListener(event, listener));
        };
    }, []);
};

/*
 * Registers onKeyDown event behavior for the ESC key for dismissable components like Modal and Popover.
 * Accepts a callback which is called when the ESC key is pressed.
 */

const useOnEscKeyDown = callback => {
    const handleEscKeyPress = ({
        keyCode
    }) => keyCode === 27 && callback();

    React.useEffect(() => {
        document.addEventListener("keydown", handleEscKeyPress);
        return () => document.removeEventListener("keydown", handleEscKeyPress);
    }, []);
};

var LOGGING_PREFIX = "VERITAS"; // -------------------------------------
// Logging Utils
// -------------------------------------

var logging = {
    deprecationWarning: function(componentName, property, message) {
        console.warn("[" + LOGGING_PREFIX + "] DEPRECATION WARNING: " + componentName + " \"" + property + "\" is deprecated. " + message);
    },
    warning: function(componentName, message) {
        console.warn("[" + LOGGING_PREFIX + "] " + componentName + ": " + message);
    },
    throwError: function(componentName, message) {
        throw new Error(LOGGING_PREFIX + " [" + componentName + "]: " + message);
    }
};

var PREFIX$1 = "vds-badge";
var COMPONENT_NAME = "Badge";
var MAX_LABEL_LENGTH = 3;
/**
 * Badges are used to indicate hidden information.
 *
 * Badges are currently only meant for use through a component rather than on their own.
 */

var Badge = function(_a) {
    var children = _a.children,
        displayLabel = _a.displayLabel,
        a11yLabel = _a.a11yLabel;

    if (displayLabel.toString().length > MAX_LABEL_LENGTH) {
        logging.warning(COMPONENT_NAME, "\"displayLabel\" should be " + MAX_LABEL_LENGTH + " or less characters");
    }

    return /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$1
    }, children, /*#__PURE__*/ React__default.createElement("span", {
        className: PREFIX$1 + "__circle",
        role: "status",
        "aria-live": "polite"
    }, /*#__PURE__*/ React__default.createElement("span", {
        "aria-hidden": true
    }, displayLabel), /*#__PURE__*/ React__default.createElement(VisuallyHidden, null, a11yLabel)));
};

var PREFIX$2 = "vds-icon";
/** Icons help clarify actions, status, and feedback on the interface. Check out the full `Icon` Library for specific icons. */

var Icon = function(_a) {
    var children = _a.children,
        color = _a.color,
        _b = _a.size,
        size = _b === void 0 ? "md" : _b,
        title = _a.title,
        _c = _a.hidden,
        hidden = _c === void 0 ? false : _c;
    var className = classnames(PREFIX$2, size !== "md" && PREFIX$2 + "--" + size, color && "vds-color--" + color);
    return /*#__PURE__*/ React__default.createElement("i", {
        className: className,
        role: "img",
        "aria-label": title,
        "aria-hidden": hidden
    }, children);
};

function _extends() {
    _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    return _extends.apply(this, arguments);
}

var PREFIX$3 = "vds-round-button";
var COMPONENT = "RoundButton";
/** Buttons trigger actions throughout the interface. They can also be used for navigation. */

var RoundButton = function(_a) {
    var _b, _c, _d, _e;

    var icon = _a.icon,
        iconRight = _a.iconRight,
        showLabel = _a.showLabel,
        label = _a.label,
        disabled = _a.disabled,
        external = _a.external,
        href = _a.href,
        loading = _a.loading,
        onClick = _a.onClick,
        small = _a.small,
        testID = _a.testID,
        _f = _a.type,
        type = _f === void 0 ? "button" : _f,
        _g = _a.variant,
        variant = _g === void 0 ? "default" : _g;

    if (iconRight && !showLabel) {
        logging.throwError(COMPONENT, '"iconRight" will not show up without "showLabel".');
    }

    if (!icon && !iconRight) {
        logging.throwError(COMPONENT, 'You must either specify "icon" or "iconRight"');
    }

    if (((_c = (_b = icon) === null || _b === void 0 ? void 0 : _b.props) === null || _c === void 0 ? void 0 : _c.size) || ((_e = (_d = iconRight) === null || _d === void 0 ? void 0 : _d.props) === null || _e === void 0 ? void 0 : _e.size)) {
        logging.warning(COMPONENT, 'Setting "size" on an icon within a RoundButton will have no effect.');
    } // ClassName Logic


    var className = classnames(PREFIX$3, variant && PREFIX$3 + "--" + variant, small && PREFIX$3 + "--small", showLabel && PREFIX$3 + "--with-label", icon && PREFIX$3 + "--icon", showLabel && iconRight && PREFIX$3 + "--icon-right", loading && PREFIX$3 + "--loading");
    var contentClassName = PREFIX$3 + "__content"; // Consolidate Props

    var buttonAttributes = {
        "aria-busy": loading,
        disabled: disabled,
        type: type
    };
    var linkAttributes = {
        href: href,
        role: "button",
        tabIndex: 0,
        target: external ? "_blank" : undefined
    };
    var combinedAttributes = href ? linkAttributes : buttonAttributes; // Only show the label visually when showLabel is enabled

    var labelMarkup = showLabel ? label : /*#__PURE__*/ React__default.createElement(VisuallyHidden, null, label); // Only show an icon on the right if the label is being shown

    var showRightIcon = showLabel && iconRight; // Show animation if loading

    var loadingMarkup = loading && /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$3 + "__loader"
    }, /*#__PURE__*/ React__default.createElement("div", null), /*#__PURE__*/ React__default.createElement("div", null), /*#__PURE__*/ React__default.createElement("div", null)); // Use an anchor if link button

    var Element = href ? "a" : "button";
    return /*#__PURE__*/ React__default.createElement(Element, _extends({
        className: className,
        "data-testid": testID,
        onClick: onClick
    }, combinedAttributes), /*#__PURE__*/ React__default.createElement("span", {
        className: contentClassName
    }, icon, labelMarkup, showRightIcon ? iconRight : null), loadingMarkup);
};

var PREFIX$4 = "vds-banner";
/** Banners are used to capture the attention of a user in an intrusive way about important information or persistent conditions. */

var Banner = function(_a) {
    var children = _a.children,
        closeable = _a.closeable,
        _b = _a.closeLabel,
        closeLabel = _b === void 0 ? "Close banner" : _b,
        embedded = _a.embedded,
        icon = _a.icon,
        onClose = _a.onClose,
        _c = _a.role,
        role = _c === void 0 ? "alert" : _c,
        _d = _a.variant,
        variant = _d === void 0 ? "default" : _d;
    var className = classnames(PREFIX$4, icon && PREFIX$4 + "--icon", closeable && PREFIX$4 + "--closeable", embedded && PREFIX$4 + "--embedded", variant && PREFIX$4 + "--" + variant);
    var roleType = closeable ? "alertdialog" : role;
    var closeIcon = /*#__PURE__*/ React__default.createElement(Icon, {
        color: "silver"
    }, /*#__PURE__*/ React__default.createElement("svg", {
        viewBox: "0 0 32 32"
    }, /*#__PURE__*/ React__default.createElement("path", {
        d: "M14.586 16L7.293 8.707a1 1 0 0 1 1.414-1.414L16 14.586l7.293-7.293a1 1 0 0 1 1.414 1.414L17.414 16l7.293 7.293a1 1 0 0 1-1.414 1.414L16 17.414l-7.293 7.293a1 1 0 1 1-1.414-1.414L14.586 16z",
        fillRule: "nonzero"
    })));
    var closeButton = closeable ? /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$4 + "__close-button"
    }, /*#__PURE__*/ React__default.createElement(RoundButton, {
        label: closeLabel,
        icon: closeIcon,
        onClick: onClose,
        small: true,
        variant: "minimal-inverse"
    })) : false;
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className,
        role: roleType
    }, /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$4 + "__content"
    }, icon, /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$4 + "__message"
    }, children)), closeButton);
};

var PREFIX$5 = "vds-button";
var COMPONENT_NAME$1 = "Button";
/** Buttons trigger actions throughout the interface. They can also be used for navigation. */

var Button = function(_a) {
    var _b;

    var alignRight = _a.alignRight,
        label = _a.label,
        disabled = _a.disabled,
        external = _a.external,
        full = _a.full,
        href = _a.href,
        icon = _a.icon,
        iconRight = _a.iconRight,
        iconOnly = _a.iconOnly,
        loading = _a.loading,
        onClick = _a.onClick,
        small = _a.small,
        testID = _a.testID,
        _c = _a.type,
        type = _c === void 0 ? "button" : _c,
        _d = _a.variant,
        variant = _d === void 0 ? "default" : _d;

    if (iconOnly) {
        logging.deprecationWarning(COMPONENT_NAME$1, "iconOnly", "Use RoundButton instead for icon-only buttons.");
    }

    if (alignRight) {
        logging.deprecationWarning(COMPONENT_NAME$1, "alignRight", "Use iconRight instead to place an icon to the right of the button text.");
    } // ClassName Logic


    var className = classnames(PREFIX$5, variant && PREFIX$5 + "--" + variant, small && PREFIX$5 + "--small", full && PREFIX$5 + "--full", loading && PREFIX$5 + "--loading", (icon || iconRight) && PREFIX$5 + "__icon", (_b = {}, _b[PREFIX$5 + "__icon--left"] = icon && !iconRight, _b[PREFIX$5 + "__icon--right"] = !icon && iconRight, _b[PREFIX$5 + "__icon--both"] = icon && iconRight, _b));
    var contentClassName = PREFIX$5 + "__content"; // Consolidate Props

    var buttonAttributes = {
        className: className,
        "aria-busy": loading,
        disabled: disabled,
        onClick: onClick,
        type: type
    };
    var linkAttributes = {
        className: className,
        href: href,
        onClick: onClick,
        role: "button",
        tabIndex: 0,
        target: external ? "_blank" : undefined
    };
    var combinedAttributes = href ? linkAttributes : buttonAttributes; // Show animation if loading

    var loadingMarkup = loading && /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$5 + "__loader"
    }, /*#__PURE__*/ React__default.createElement("div", null), /*#__PURE__*/ React__default.createElement("div", null), /*#__PURE__*/ React__default.createElement("div", null)); // Use an anchor if link button

    var Element = href ? "a" : "button";
    return /*#__PURE__*/ React__default.createElement(Element, _extends({}, combinedAttributes, {
        "data-testid": testID
    }), /*#__PURE__*/ React__default.createElement("span", {
        className: contentClassName
    }, icon ? icon : null, label, iconRight ? iconRight : null), loadingMarkup);
};

var PREFIX$6 = "vds-checkbox";
/** Checkbox is a single control for toggling a choice. Use `CheckboxGroup` for multiple options. */

var Checkbox = function(_a) {
    var id = _a.id,
        label = _a.label,
        autoFocus = _a.autoFocus,
        checked = _a.checked,
        defaultChecked = _a.defaultChecked,
        disabled = _a.disabled,
        hiddenLabel = _a.hiddenLabel,
        _b = _a.name,
        name = _b === void 0 ? PREFIX$6 : _b,
        onChange = _a.onChange,
        required = _a.required,
        testID = _a.testID,
        value = _a.value;
    var className = classnames(PREFIX$6, hiddenLabel && PREFIX$6 + "--hidden");
    var labelMarkup = hiddenLabel ? /*#__PURE__*/ React__default.createElement(VisuallyHidden, null, label) : label;
    var labelId = PREFIX$6 + "--label--" + id;
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className
    }, /*#__PURE__*/ React__default.createElement("input", {
        "aria-labelledby": labelId,
        autoFocus: autoFocus,
        checked: checked,
        className: PREFIX$6 + "__input",
        "data-testid": testID,
        defaultChecked: defaultChecked,
        disabled: disabled,
        id: id,
        name: name,
        onChange: onChange,
        required: required,
        type: "checkbox",
        value: value
    }), /*#__PURE__*/ React__default.createElement("label", {
        id: labelId,
        className: PREFIX$6 + "__label",
        htmlFor: id
    }, labelMarkup), /*#__PURE__*/ React__default.createElement("i", {
        className: "vds-icon vds-icon--sm",
        role: "img",
        "aria-hidden": "true"
    }, /*#__PURE__*/ React__default.createElement("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24"
    }, /*#__PURE__*/ React__default.createElement("path", {
        d: "M17 5.3a1.2 1.2 0 1 1 2 1.4l-7.8 12c-.4.6-1.3.7-1.9.2l-4.2-4.2A1.3 1.3 0 0 1 7 12.9l3 3.1 7-10.7z"
    }))));
};

var PREFIX$7 = "vds-checkbox-group";
/** CheckboxGroup allows multiple values to be selected from a list. */

var CheckboxGroup = function(_a) {
    var children = _a.children,
        title = _a.title,
        hiddenTitle = _a.hiddenTitle,
        _b = _a.name,
        name = _b === void 0 ? "vds-checkbox" : _b,
        onChange = _a.onChange;
    var className = classnames(PREFIX$7);
    var titleClassName = classnames(PREFIX$7 + "__title", hiddenTitle && "vds-visually-hidden");
    var checkboxChildren = React.Children.map(children, function(child) {
        return /*#__PURE__*/ React.cloneElement(child, {
            name: name,
            onChange: onChange
        });
    });
    return /*#__PURE__*/ React__default.createElement("fieldset", {
        className: className
    }, /*#__PURE__*/ React__default.createElement("legend", {
        className: titleClassName
    }, title), checkboxChildren);
};

var PREFIX$8 = "vds-code";
/** Code displays short strings of code snippets inline with body text. */

var Code = function(_a) {
    var children = _a.children;
    var className = classnames(PREFIX$8);
    return /*#__PURE__*/ React__default.createElement("code", {
        className: className
    }, children);
};

var PREFIX$9 = "vds-codeblock";
/** CodeBlocks display preformatted blocks of code longer than a line or single expression. */

var CodeBlock = function(_a) {
    var children = _a.children,
        numbered = _a.numbered;
    var className = classnames(PREFIX$9, numbered && PREFIX$9 + "--numbered");
    return /*#__PURE__*/ React__default.createElement("pre", {
        className: className
    }, numbered ? children && typeof children === "string" && children.split("\n").map(function(line, key) {
        return /*#__PURE__*/ React__default.createElement("code", {
            key: key
        }, line);
    }) : /*#__PURE__*/ React__default.createElement("code", null, children));
};

var PREFIX$a = "vds-flex";
/** Flex is an invisible wrapper used to lay out other components in a flexible manner, with control over alignment, spacing and wrapping.
 *  The API is adapted from the [Flexbox Layout module](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) for performing small-scale layouts,
 *  rather than full page layouts.
 */

var Flex = function(_a) {
    var children = _a.children,
        _b = _a.align,
        align = _b === void 0 ? "start" : _b,
        center = _a.center,
        _c = _a.direction,
        direction = _c === void 0 ? "row" : _c,
        full = _a.full,
        inline = _a.inline,
        _d = _a.justify,
        justify = _d === void 0 ? "start" : _d,
        _e = _a.spacing,
        spacing = _e === void 0 ? "2x" : _e,
        _f = _a.wrap,
        wrap = _f === void 0 ? "wrap" : _f;
    var className = classnames(PREFIX$a, align && !center && PREFIX$a + "--align-" + align, center && PREFIX$a + "--center", direction !== "row" && PREFIX$a + "--direction-" + direction, full && PREFIX$a + "--full", inline && PREFIX$a + "--inline", justify && !center && PREFIX$a + "--justify-" + justify, spacing !== "none" && PREFIX$a + "--spacing-" + spacing, wrap !== "wrap" && PREFIX$a + "--wrap-" + wrap);
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className
    }, React.Children.toArray(children).map(function(child, i) {
        return /*#__PURE__*/ React__default.createElement("div", {
            className: PREFIX$a + "__item",
            key: i.toString()
        }, child);
    }));
};

var PREFIX$b = "vds-form-fieldset";
/** A FormFieldset groups related form elements together and improves accessibility. */

var FormFieldset = function(_a) {
    var children = _a.children,
        title = _a.title,
        disabled = _a.disabled,
        hiddenTitle = _a.hiddenTitle;
    var className = classnames(PREFIX$b);
    var titleClassName = classnames(PREFIX$b + "__title", hiddenTitle && "vds-visually-hidden");
    return /*#__PURE__*/ React__default.createElement("fieldset", {
        className: className,
        disabled: disabled
    }, /*#__PURE__*/ React__default.createElement("legend", {
        className: titleClassName
    }, title), children);
};

var PREFIX$c = "vds-form-validation";
var IconWarning = /*#__PURE__*/ React__default.createElement("i", {
    className: "vds-icon",
    role: "img",
    "aria-hidden": "true"
}, /*#__PURE__*/ React__default.createElement("svg", {
    viewBox: "0 0 32 32"
}, /*#__PURE__*/ React__default.createElement("path", {
    d: "M16.874 6.514l10 18A1 1 0 0 1 26 26H6a1 1 0 0 1-.874-1.486l10-18a1 1 0 0 1 1.748 0zM7.7 24h16.6L16 9.06 7.7 24zm8.3-2a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm-1-8a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4z",
    fillRule: "nonzero"
})));
var IconChecked = /*#__PURE__*/ React__default.createElement("i", {
    className: "vds-icon",
    role: "img",
    "aria-hidden": "true"
}, /*#__PURE__*/ React__default.createElement("svg", {
    viewBox: "0 0 32 32"
}, /*#__PURE__*/ React__default.createElement("path", {
    d: "M16 6c5.523 0 10 4.477 10 10s-4.477 10-10 10S6 21.523 6 16 10.477 6 16 6zm0 2a8 8 0 100 16 8 8 0 000-16zm3.143 3.486a1 1 0 011.714 1.028l-4.8 8a1 1 0 01-1.564.193l-3.2-3.2a1 1 0 011.414-1.414l2.294 2.294z"
})));
/** FormValidation provides a helpful message for validating data in a form component. */

var FormValidation = function(_a) {
    var message = _a.message,
        _b = _a.variant,
        variant = _b === void 0 ? "error" : _b;
    var className = classnames(PREFIX$c, variant && PREFIX$c + "--" + variant);
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className,
        role: "alert"
    }, /*#__PURE__*/ React__default.createElement("span", null, message), variant === "success" ? IconChecked : IconWarning);
};

var PREFIX$d = "vds-heading";
/** Headings are used as the titles of important sections on a page of an interface. */

var Heading = function(_a) {
    var children = _a.children,
        DefaultElement = _a.size,
        _b = _a.align,
        align = _b === void 0 ? "left" : _b,
        OverrideElement = _a.as,
        _c = _a.color,
        color = _c === void 0 ? "black" : _c,
        _d = _a.spacing,
        spacing = _d === void 0 ? "3x" : _d;
    var className = classnames(DefaultElement && PREFIX$d + "--" + DefaultElement, align !== "left" && "vds-text-align--" + align, "vds-spacing--stack-" + spacing, color !== "black" && "vds-color--" + color);

    if (OverrideElement) {
        return /*#__PURE__*/ React__default.createElement(OverrideElement, {
            className: className
        }, children);
    }

    return /*#__PURE__*/ React__default.createElement(DefaultElement, {
        className: className
    }, children);
};

var TOPHER_THUMBNAIL_SUFFIX = "_thumb_w32_h";
var TOPHER_URL_SUBSTRING = "/topher/";
var utils = {
    isTopherUrl: function(url) {
        return url.indexOf(TOPHER_URL_SUBSTRING) > -1;
    },
    getTopherPlaceholder: function(url) {
        var startExtension = url.lastIndexOf(".");

        if (startExtension > -1) {
            return url.slice(0, startExtension) + TOPHER_THUMBNAIL_SUFFIX + url.slice(startExtension);
        } else {
            return url;
        }
    }
};

var PREFIX$e = "vds-image-loader";
/**
 * ImageLoader is a progressive image loader. It will first display a low-scale placeholder
 * image, and will then transition to the full-scale image once it has loaded.
 */

var ImageLoader = function(_a) {
    var children = _a.children,
        height = _a.height,
        label = _a.label,
        onLoad = _a.onLoad,
        onClick = _a.onClick,
        placeholder = _a.placeholder,
        src = _a.src,
        width = _a.width;

    var _b = React.useState(true),
        loading = _b[0],
        setLoading = _b[1];

    var containerClass = classnames(PREFIX$e, PREFIX$e + "--" + (loading ? "loading" : "loaded"), onClick && PREFIX$e + "--clickable");
    var placeholderClass = classnames(PREFIX$e + "__placeholder");
    var imageClass = classnames(PREFIX$e + "__full");
    React.useEffect(function() {
        setLoading(true);
    }, [src]);

    var handleImageLoad = function() {
        setLoading(false);
        if (onLoad) onLoad();
    };

    var containerStyle = React.useMemo(function() {
        return {
            height: height,
            width: width
        };
    }, [height, width]);
    var placeholderUrl = React.useMemo(function() {
        var url = placeholder;

        if (!url && utils.isTopherUrl(src)) {
            url = utils.getTopherPlaceholder(src);
        }

        return url;
    }, [placeholder, src]);
    var placeholderStyle = React.useMemo(function() {
        return {
            backgroundImage: "url(" + placeholderUrl + ")"
        };
    }, [placeholderUrl]);
    var imageStyle = React.useMemo(function() {
        return {
            backgroundImage: "url(" + src + ")"
        };
    }, [src]);
    return /*#__PURE__*/ React__default.createElement("div", {
        className: containerClass,
        style: containerStyle,
        onClick: onClick,
        role: onClick && "button"
    }, /*#__PURE__*/ React__default.createElement("img", {
        hidden: true,
        src: src,
        onLoad: handleImageLoad
    }), placeholderUrl && /*#__PURE__*/ React__default.createElement("div", {
        className: placeholderClass,
        style: placeholderStyle
    }, loading && children), /*#__PURE__*/ React__default.createElement("div", {
        "aria-label": label,
        className: imageClass,
        style: imageStyle
    }, !loading && children));
};

var PREFIX$f = "vds-link";
/** Links are used to navigate to a new page or view, changing the URL, or jumping internally to anchors on the same page. */

var Link = function(_a) {
    var children = _a.children,
        href = _a.href,
        external = _a.external,
        onClick = _a.onClick,
        testID = _a.testID;
    var className = classnames(PREFIX$f);
    return /*#__PURE__*/ React__default.createElement("a", {
        className: className,
        "data-testid": testID,
        href: href,
        onClick: onClick,
        rel: external ? "noopener noreferrer" : undefined,
        target: external ? "_blank" : undefined
    }, children);
};

var PREFIX$g = "vds-loading";
/** Loading indicates that an action is being processed. */

var Loading = function(_a) {
    var busy = _a.busy,
        children = _a.children,
        _b = _a.label,
        label = _b === void 0 ? "Loading…" : _b,
        _c = _a.size,
        size = _c === void 0 ? "md" : _c;
    var className = classnames(PREFIX$g, PREFIX$g + "--" + size, busy && PREFIX$g + "--busy");
    var spinnerMarkup = /*#__PURE__*/ React__default.createElement("i", {
        className: PREFIX$g + "__spinner"
    });
    var childrenMarkup = /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$g + "__children"
    }, children);
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className,
        role: "status",
        "aria-label": label
    }, !children || busy ? spinnerMarkup : null, children && childrenMarkup);
};

var LogoDefault = function(_a) {
    var iconClass = _a.iconClass,
        titleClass = _a.titleClass;
    return /*#__PURE__*/ React__default.createElement(React__default.Fragment, null, /*#__PURE__*/ React__default.createElement("path", {
        className: iconClass,
        d: "M29 .5l1 .5v13c0 5.55-2.9 8.7-6 10.1l-7.6 4.4c-.07.02-.13.06-.2.1l-.07.04C14.48 29.54 12.68 30 11 30 6 30 0 26 0 18V6l2 1v11c0 8 6 10 9 10 1.86 0 4.87-.77 6.9-3.25C14.17 23.87 10 20.68 10 14V2.2L2 7 0 6l10-6 1 .5 1 .5v13c0 6.94 4.52 8.6 7.02 8.93.6-1.3.98-2.93.98-4.93V5l2 1v12c0 1.85-.32 3.5-.88 4.9C23.65 22.56 28 20.8 28 14V2.25L22 6l-2-1 8-5z"
    }), /*#__PURE__*/ React__default.createElement("path", {
        className: titleClass,
        d: "M57.6 17.24c0 2.55-2.1 4.4-4.97 4.4s-4.96-1.85-4.96-4.4v-9.4h-2v9.5c0 3.33 2.9 6.17 6.96 6.17 4.08 0 6.96-2.93 6.96-6.16v-9.5h-2zm16.3-9.4H68.5V23.5h5.37c4.46 0 7.53-3.03 7.53-7.83 0-4.7-3.07-7.83-7.54-7.83zm-.2 13.7h-3.2V9.8h3.2c3.36 0 5.75 2.25 5.75 5.87 0 3.92-2.48 5.78-5.76 5.88zm43.5.3c-3.6 0-5.97-2.64-5.97-6.17 0-3.52 2.48-6.07 5.96-6.07 2.77 0 4.46 1.57 4.46 1.57l.8-1.38s-1.8-1.87-5.47-1.87c-4.78 0-7.76 3.53-7.76 7.74 0 4.3 3.08 7.94 7.95 7.94 3.76 0 5.65-2.54 5.65-2.54l-1.1-1.18c-.1-.1-1.58 1.96-4.56 1.96zm14.88-14h2V23.5h-2zM143 9.8h4.97v13.7h2V9.8h4.95V7.83h-11.9m30.57 0L168.82 15l-4.87-7.16h-2.08l5.95 8.7v6.97h2v-6.95l5.85-8.7m-81.43 0L88.1 23.5h1.97l1.7-4.5 6.45-1.37 2.18 5.88h2L96.32 7.85h-2.08zm-1.9 9.3l3-7.26h.1l2.47 6.16-5.56 1.08z"
    }));
};

var LogoIconOnly = function(_a) {
    var iconClass = _a.iconClass;
    return /*#__PURE__*/ React__default.createElement(React__default.Fragment, null, /*#__PURE__*/ React__default.createElement("path", {
        className: iconClass,
        d: "M29 .5l1 .5v13c0 5.55-2.9 8.7-6 10.1l-7.6 4.4c-.07.02-.13.06-.2.1l-.07.04C14.48 29.54 12.68 30 11 30 6 30 0 26 0 18V6l2 1v11c0 8 6 10 9 10 1.86 0 4.87-.77 6.9-3.25C14.17 23.87 10 20.68 10 14V2.2L2 7 0 6l10-6 1 .5 1 .5v13c0 6.94 4.52 8.6 7.02 8.93.6-1.3.98-2.93.98-4.93V5l2 1v12c0 1.85-.32 3.5-.88 4.9C23.65 22.56 28 20.8 28 14V2.25L22 6l-2-1 8-5 1 .5z"
    }));
};

var LogoStacked = function(_a) {
    var iconClass = _a.iconClass,
        titleClass = _a.titleClass;
    return /*#__PURE__*/ React__default.createElement(React__default.Fragment, null, /*#__PURE__*/ React__default.createElement("path", {
        className: iconClass,
        d: "M38.35 0L16 12.9v29.53C16 56 27 67 40.58 67c4.5 0 8.72-1.2 12.34-3.3l18.16-10.46C78.23 49.5 83 42.04 83 33.44V2.53L78.64 0 60.78 10.32v32.1c0 1.38-.2 2.74-.46 4.07-.26 1.28-.66 2.54-1.17 3.76-.13.3-.28.62-.43.93-.54-.07-1.07-.16-1.6-.27-1.15-.23-2.28-.58-3.36-1.04-1.06-.45-2.08-1-3.04-1.65-.95-.64-1.84-1.38-2.65-2.2-.8-.8-1.55-1.7-2.2-2.63-.64-.96-1.2-1.98-1.64-3.04-.46-1.07-.8-2.2-1.04-3.34-.26-1.18-.38-2.4-.38-3.6V2.57L38.35 0zm10.07 60.96c-1.2.5-2.48.9-3.77 1.17-1.33.27-2.7.4-4.07.4s-2.73-.13-4.06-.4c-1.3-.27-2.56-.66-3.78-1.17-1.2-.5-2.34-1.13-3.42-1.86-1.06-.72-2.07-1.54-2.98-2.45-.9-.9-1.74-1.92-2.46-2.98-.73-1.08-1.35-2.22-1.86-3.4-.5-1.23-.9-2.5-1.17-3.78-.27-1.34-.4-2.7-.4-4.07V15.47l17.94-10.3v28.26c0 10.74 7.55 19.7 17.68 21.85-.4.47-.8.93-1.25 1.37-.9.9-1.92 1.73-3 2.45-1.06.73-2.2 1.35-3.4 1.86zm29.85-23.92c-.23 1.14-.58 2.27-1.04 3.34-.45 1.06-1 2.08-1.65 3.04-.64.94-1.38 1.83-2.2 2.64-.8.8-1.7 1.55-2.64 2.2-.96.63-1.98 1.2-3.04 1.63-1.08.45-2.2.8-3.36 1.03-.23.05-.46.1-.7.13 1-2.68 1.57-5.6 1.57-8.62V12.9l13.53-7.74v28.27c0 1.22-.22 2.43-.46 3.6z"
    }), /*#__PURE__*/ React__default.createElement("path", {
        className: titleClass,
        d: "M8.67 92.3c0 2-1.54 3.62-3.8 3.62-2.25 0-3.85-1.62-3.85-3.6V85H0v7.33c0 2.56 1.78 4.64 4.87 4.64 3.1 0 4.82-2.08 4.82-4.64V85H8.66v7.3zM21.6 85.17h-3.74v11.66h3.73c3.48 0 5.82-2.16 5.82-5.84 0-3.66-2.34-5.83-5.83-5.83zm-.13 10.48h-2.42v-9.47h2.42c2.85 0 4.76 1.74 4.76 4.8 0 3.1-1.9 4.67-4.76 4.67z M37.6 85.17l-4.75 11.66h1.25l1.26-3.1 5.27-1.1 1.7 4.2h1.24l-4.73-11.66H37.6zm.6 1.62h.03l1.95 4.76-4.3.87 2.32-5.64z M55.02 95.92c-2.76 0-4.7-2.25-4.7-5 0-2.74 1.94-4.84 4.67-4.84 2.17 0 3.52 1.28 3.52 1.28l.62-.84s-1.4-1.5-4.2-1.5c-3.3 0-5.82 2.55-5.82 5.9 0 3.37 2.44 6.05 5.88 6.05 2.86 0 4.45-1.8 4.45-1.8l-.66-.8s-1.43 1.55-3.78 1.55z M67 85.17h1.2v11.66H67z M75.17 86.18h4.25v10.65h1.2V86.18h4.24v-1h-9.7zM98.65 85.17L94.9 90.8h-.02l-3.75-5.63h-1.3l4.4 6.64v5.03h1.18V91.8l4.54-6.63z"
    }));
};

var PREFIX$h = "vds-logo";
var SVG_SIZES = {
    default: {
        height: "30",
        width: "180"
    },
    stacked: {
        height: "97",
        width: "100"
    },
    icon: {
        height: "30",
        width: "30"
    }
};
/** Logo displays different variations of the Udacity logo in SVG form */

var Logo = function(_a) {
    var inverted = _a.inverted,
        _b = _a.variant,
        variant = _b === void 0 ? "default" : _b,
        height = _a.height,
        width = _a.width,
        onClick = _a.onClick;
    var containerClass = classnames(PREFIX$h, PREFIX$h + "--" + variant, inverted && PREFIX$h + "--inverted", onClick && PREFIX$h + "--clickable");
    var iconClass = classnames(PREFIX$h + "__icon");
    var titleClass = classnames(PREFIX$h + "__title");
    var svgSize = React.useMemo(function() {
        return SVG_SIZES[variant];
    }, [variant]);
    var containerStyle = React.useMemo(function() {
        var size = {};

        if (height || width) {
            size.height = height;
            size.width = width;
        } else if (!height && !width) {
            size.height = svgSize.height + "px";
            size.width = svgSize.width + "px";
        }

        return size;
    }, [svgSize, height, width]);
    var svgStyle = React.useMemo(function() {
        var size = {};

        if (containerStyle.height) {
            size.height = "100%";
        }

        if (containerStyle.width) {
            size.width = "100%";
        }

        return size;
    }, [containerStyle, height, width]);
    return /*#__PURE__*/ React__default.createElement("div", {
        className: containerClass,
        style: containerStyle,
        onClick: onClick,
        role: onClick && "button"
    }, /*#__PURE__*/ React__default.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 " + svgSize.width + " " + svgSize.height,
        style: svgStyle
    }, /*#__PURE__*/ React__default.createElement("title", null, "Udacity Logo"), /*#__PURE__*/ React__default.createElement("g", {
        fill: "none"
    }, variant === "default" && /*#__PURE__*/ React__default.createElement(LogoDefault, {
        iconClass: iconClass,
        titleClass: titleClass
    }), variant === "stacked" && /*#__PURE__*/ React__default.createElement(LogoStacked, {
        iconClass: iconClass,
        titleClass: titleClass
    }), variant === "icon" && /*#__PURE__*/ React__default.createElement(LogoIconOnly, {
        iconClass: iconClass
    }))));
};

/*!
 * tabbable 5.1.5
 * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
 */
var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
var candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');
var matches = typeof Element === 'undefined' ? function() {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

var getCandidates = function getCandidates(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));

    if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
    }

    candidates = candidates.filter(filter);
    return candidates;
};

var isContentEditable = function isContentEditable(node) {
    return node.contentEditable === 'true';
};

var getTabindex = function getTabindex(node) {
    var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);

    if (!isNaN(tabindexAttr)) {
        return tabindexAttr;
    } // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.


    if (isContentEditable(node)) {
        return 0;
    } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    //  yet they are still part of the regular tab order; in FF, they get a default
    //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    //  order, consider their tab index to be 0.


    if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {
        return 0;
    }

    return node.tabIndex;
};

var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};

var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
};

var isHiddenInput = function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
};

var isDetailsWithSummary = function isDetailsWithSummary(node) {
    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === 'SUMMARY';
    });
    return r;
};

var getCheckedRadio = function getCheckedRadio(nodes, form) {
    for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked && nodes[i].form === form) {
            return nodes[i];
        }
    }
};

var isTabbableRadio = function isTabbableRadio(node) {
    if (!node.name) {
        return true;
    }

    var radioScope = node.form || node.ownerDocument;

    var queryRadios = function queryRadios(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };

    var radioSet;

    if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
        radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
        try {
            radioSet = queryRadios(node.name);
        } catch (err) {
            // eslint-disable-next-line no-console
            console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
            return false;
        }
    }

    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
};

var isRadio = function isRadio(node) {
    return isInput(node) && node.type === 'radio';
};

var isNonTabbableRadio = function isNonTabbableRadio(node) {
    return isRadio(node) && !isTabbableRadio(node);
};

var isHidden = function isHidden(node) {
    if (getComputedStyle(node).visibility === 'hidden') {
        return true;
    }

    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
    }

    while (node) {
        if (getComputedStyle(node).display === 'none') {
            return true;
        }

        node = node.parentElement;
    }

    return false;
};

var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node) ||
        /* For a details element with a summary, the summary element gets the focused  */
        isDetailsWithSummary(node)) {
        return false;
    }

    return true;
};

var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(node) {
    if (!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
        return false;
    }

    return true;
};

var tabbable = function tabbable(el, options) {
    options = options || {};
    var regularTabbables = [];
    var orderedTabbables = [];
    var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable);
    candidates.forEach(function(candidate, i) {
        var candidateTabindex = getTabindex(candidate);

        if (candidateTabindex === 0) {
            regularTabbables.push(candidate);
        } else {
            orderedTabbables.push({
                documentOrder: i,
                tabIndex: candidateTabindex,
                node: candidate
            });
        }
    });
    var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function(a) {
        return a.node;
    }).concat(regularTabbables);
    return tabbableNodes;
};

var focusableCandidateSelector = /* #__PURE__ */ candidateSelectors.concat('iframe').join(',');

var isFocusable = function isFocusable(node) {
    if (!node) {
        throw new Error('No node provided');
    }

    if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
    }

    return isNodeMatchingSelectorFocusable(node);
};

/*!
 * focus-trap 6.3.0
 * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
 */

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }

    return obj;
}

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }

    return keys;
}

function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }

    return target;
}

var activeFocusDelay;

var activeFocusTraps = function() {
    var trapQueue = [];
    return {
        activateTrap: function activateTrap(trap) {
            if (trapQueue.length > 0) {
                var activeTrap = trapQueue[trapQueue.length - 1];

                if (activeTrap !== trap) {
                    activeTrap.pause();
                }
            }

            var trapIndex = trapQueue.indexOf(trap);

            if (trapIndex === -1) {
                trapQueue.push(trap);
            } else {
                // move this existing trap to the front of the queue
                trapQueue.splice(trapIndex, 1);
                trapQueue.push(trap);
            }
        },
        deactivateTrap: function deactivateTrap(trap) {
            var trapIndex = trapQueue.indexOf(trap);

            if (trapIndex !== -1) {
                trapQueue.splice(trapIndex, 1);
            }

            if (trapQueue.length > 0) {
                trapQueue[trapQueue.length - 1].unpause();
            }
        }
    };
}();

var isSelectableInput = function isSelectableInput(node) {
    return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};

var isEscapeEvent = function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
};

var isTabEvent = function isTabEvent(e) {
    return e.key === 'Tab' || e.keyCode === 9;
};

var delay = function delay(fn) {
    return setTimeout(fn, 0);
}; // Array.find/findIndex() are not supported on IE; this replicates enough
//  of Array.findIndex() for our needs


var findIndex = function findIndex(arr, fn) {
    var idx = -1;
    arr.every(function(value, i) {
        if (fn(value)) {
            idx = i;
            return false; // break
        }

        return true; // next
    });
    return idx;
};
/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */


var valueOrHandler = function valueOrHandler(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
    }

    return typeof value === 'function' ? value.apply(void 0, params) : value;
};

var createFocusTrap = function createFocusTrap(elements, userOptions) {
    var doc = document;

    var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true
    }, userOptions);

    var state = {
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying the first and last tabbable nodes in all containers/groups in
        //  the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{ container: HTMLElement, firstTabbableNode: HTMLElement|null, lastTabbableNode: HTMLElement|null }>}
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false
    };
    var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later

    var containersContain = function containersContain(element) {
        return state.containers.some(function(container) {
            return container.contains(element);
        });
    };

    var getNodeForOption = function getNodeForOption(optionName) {
        var optionValue = config[optionName];

        if (!optionValue) {
            return null;
        }

        var node = optionValue;

        if (typeof optionValue === 'string') {
            node = doc.querySelector(optionValue);

            if (!node) {
                throw new Error("`".concat(optionName, "` refers to no known node"));
            }
        }

        if (typeof optionValue === 'function') {
            node = optionValue();

            if (!node) {
                throw new Error("`".concat(optionName, "` did not return a node"));
            }
        }

        return node;
    };

    var getInitialFocusNode = function getInitialFocusNode() {
        var node;

        if (getNodeForOption('initialFocus') !== null) {
            node = getNodeForOption('initialFocus');
        } else if (containersContain(doc.activeElement)) {
            node = doc.activeElement;
        } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption('fallbackFocus');
        }

        if (!node) {
            throw new Error('Your focus-trap needs to have at least one focusable element');
        }

        return node;
    };

    var updateTabbableNodes = function updateTabbableNodes() {
        state.tabbableGroups = state.containers.map(function(container) {
            var tabbableNodes = tabbable(container);

            if (tabbableNodes.length > 0) {
                return {
                    container: container,
                    firstTabbableNode: tabbableNodes[0],
                    lastTabbableNode: tabbableNodes[tabbableNodes.length - 1]
                };
            }

            return undefined;
        }).filter(function(group) {
            return !!group;
        }); // remove groups with no tabbable nodes
        // throw if no groups have tabbable nodes and we don't have a fallback focus node either

        if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus')) {
            throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
        }
    };

    var tryFocus = function tryFocus(node) {
        if (node === doc.activeElement) {
            return;
        }

        if (!node || !node.focus) {
            tryFocus(getInitialFocusNode());
            return;
        }

        node.focus({
            preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;

        if (isSelectableInput(node)) {
            node.select();
        }
    };

    var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
        var node = getNodeForOption('setReturnFocus');
        return node ? node : previousActiveElement;
    }; // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event.


    var checkPointerDown = function checkPointerDown(e) {
        if (containersContain(e.target)) {
            // allow the click since it ocurred inside the trap
            return;
        }

        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
            // immediately deactivate the trap
            trap.deactivate({
                // if, on deactivation, we should return focus to the node originally-focused
                //  when the trap was activated (or the configured `setReturnFocus` node),
                //  then assume it's also OK to return focus to the outside node that was
                //  just clicked, causing deactivation, as long as that node is focusable;
                //  if it isn't focusable, then return focus to the original node focused
                //  on activation (or the configured `setReturnFocus` node)
                // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
                //  which will result in the outside click setting focus to the node
                //  that was clicked, whether it's focusable or not; by setting
                //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
                //  on activation (or the configured `setReturnFocus` node)
                returnFocus: config.returnFocusOnDeactivate && !isFocusable(e.target)
            });
            return;
        } // This is needed for mobile devices.
        // (If we'll only let `click` events through,
        // then on mobile they will be blocked anyways if `touchstart` is blocked.)


        if (valueOrHandler(config.allowOutsideClick, e)) {
            // allow the click outside the trap to take place
            return;
        } // otherwise, prevent the click


        e.preventDefault();
    }; // In case focus escapes the trap for some strange reason, pull it back in.


    var checkFocusIn = function checkFocusIn(e) {
        var targetContained = containersContain(e.target); // In Firefox when you Tab out of an iframe the Document is briefly focused.

        if (targetContained || e.target instanceof Document) {
            if (targetContained) {
                state.mostRecentlyFocusedNode = e.target;
            }
        } else {
            // escaped! pull it back in to where it just left
            e.stopImmediatePropagation();
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
        }
    }; // Hijack Tab events on the first and last focusable nodes of the trap,
    // in order to prevent focus from escaping. If it escapes for even a
    // moment it can end up scrolling the page and causing confusion so we
    // kind of need to capture the action at the keydown phase.


    var checkTab = function checkTab(e) {
        updateTabbableNodes();
        var destinationNode = null;

        if (state.tabbableGroups.length > 0) {
            // make sure the target is actually contained in a group
            var containerIndex = findIndex(state.tabbableGroups, function(_ref) {
                var container = _ref.container;
                return container.contains(e.target);
            });

            if (containerIndex < 0) {
                // target not found in any group: quite possible focus has escaped the trap,
                //  so bring it back in to...
                if (e.shiftKey) {
                    // ...the last node in the last group
                    destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
                } else {
                    // ...the first node in the first group
                    destinationNode = state.tabbableGroups[0].firstTabbableNode;
                }
            } else if (e.shiftKey) {
                // REVERSE
                var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
                    var firstTabbableNode = _ref2.firstTabbableNode;
                    return e.target === firstTabbableNode;
                });

                if (startOfGroupIndex >= 0) {
                    var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
                    var destinationGroup = state.tabbableGroups[destinationGroupIndex];
                    destinationNode = destinationGroup.lastTabbableNode;
                }
            } else {
                // FORWARD
                var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
                    var lastTabbableNode = _ref3.lastTabbableNode;
                    return e.target === lastTabbableNode;
                });

                if (lastOfGroupIndex >= 0) {
                    var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;

                    var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
                    destinationNode = _destinationGroup.firstTabbableNode;
                }
            }
        } else {
            destinationNode = getNodeForOption('fallbackFocus');
        }

        if (destinationNode) {
            e.preventDefault();
            tryFocus(destinationNode);
        }
    };

    var checkKey = function checkKey(e) {
        if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
            e.preventDefault();
            trap.deactivate();
            return;
        }

        if (isTabEvent(e)) {
            checkTab(e);
            return;
        }
    };

    var checkClick = function checkClick(e) {
        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
            return;
        }

        if (containersContain(e.target)) {
            return;
        }

        if (valueOrHandler(config.allowOutsideClick, e)) {
            return;
        }

        e.preventDefault();
        e.stopImmediatePropagation();
    }; //
    // EVENT LISTENERS
    //


    var addListeners = function addListeners() {
        if (!state.active) {
            return;
        } // There can be only one listening focus trap at a time


        activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event
        // that caused the focus trap activation.

        activeFocusDelay = config.delayInitialFocus ? delay(function() {
            tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc.addEventListener('focusin', checkFocusIn, true);
        doc.addEventListener('mousedown', checkPointerDown, {
            capture: true,
            passive: false
        });
        doc.addEventListener('touchstart', checkPointerDown, {
            capture: true,
            passive: false
        });
        doc.addEventListener('click', checkClick, {
            capture: true,
            passive: false
        });
        doc.addEventListener('keydown', checkKey, {
            capture: true,
            passive: false
        });
        return trap;
    };

    var removeListeners = function removeListeners() {
        if (!state.active) {
            return;
        }

        doc.removeEventListener('focusin', checkFocusIn, true);
        doc.removeEventListener('mousedown', checkPointerDown, true);
        doc.removeEventListener('touchstart', checkPointerDown, true);
        doc.removeEventListener('click', checkClick, true);
        doc.removeEventListener('keydown', checkKey, true);
        return trap;
    }; //
    // TRAP DEFINITION
    //


    trap = {
        activate: function activate(activateOptions) {
            if (state.active) {
                return this;
            }

            updateTabbableNodes();
            state.active = true;
            state.paused = false;
            state.nodeFocusedBeforeActivation = doc.activeElement;
            var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;

            if (onActivate) {
                onActivate();
            }

            addListeners();
            return this;
        },
        deactivate: function deactivate(deactivateOptions) {
            if (!state.active) {
                return this;
            }

            clearTimeout(activeFocusDelay);
            removeListeners();
            state.active = false;
            state.paused = false;
            activeFocusTraps.deactivateTrap(trap);
            var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;

            if (onDeactivate) {
                onDeactivate();
            }

            var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;

            if (returnFocus) {
                delay(function() {
                    tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
                });
            }

            return this;
        },
        pause: function pause() {
            if (state.paused || !state.active) {
                return this;
            }

            state.paused = true;
            removeListeners();
            return this;
        },
        unpause: function unpause() {
            if (!state.paused || !state.active) {
                return this;
            }

            state.paused = false;
            updateTabbableNodes();
            addListeners();
            return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
            var elementsAsArray = [].concat(containerElements).filter(Boolean);
            state.containers = elementsAsArray.map(function(element) {
                return typeof element === 'string' ? doc.querySelector(element) : element;
            });

            if (state.active) {
                updateTabbableNodes();
            }

            return this;
        }
    }; // initialize container elements

    trap.updateContainerElements(elements);
    return trap;
};

var focusTrap_esm = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    createFocusTrap: createFocusTrap
});

function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}

function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}

function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}







var createFocusTrap$1 = focusTrap_esm.createFocusTrap; // TODO: These issues are related to older React features which we'll likely need
//  to fix in order to move the code forward to the next major version of React.
//  @see https://github.com/davidtheclark/focus-trap-react/issues/77

/* eslint-disable react/no-find-dom-node */


var FocusTrap = /*#__PURE__*/ function(_React$Component) {
    _inherits(FocusTrap, _React$Component);

    var _super = _createSuper(FocusTrap);

    function FocusTrap(props) {
        var _this;

        _classCallCheck(this, FocusTrap);

        _this = _super.call(this, props); // We need to hijack the returnFocusOnDeactivate option,
        // because React can move focus into the element before we arrived at
        // this lifecycle hook (e.g. with autoFocus inputs). So the component
        // captures the previouslyFocusedElement in componentWillMount,
        // then (optionally) returns focus to it in componentWillUnmount.

        _this.tailoredFocusTrapOptions = {
            returnFocusOnDeactivate: false
        }; // because of the above, we maintain our own flag for this option, and
        //  default it to `true` because that's focus-trap's default

        _this.returnFocusOnDeactivate = true;
        var focusTrapOptions = props.focusTrapOptions;

        for (var optionName in focusTrapOptions) {
            if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {
                continue;
            }

            if (optionName === 'returnFocusOnDeactivate') {
                _this.returnFocusOnDeactivate = !!focusTrapOptions[optionName];
                continue;
            }

            _this.tailoredFocusTrapOptions[optionName] = focusTrapOptions[optionName];
        } // elements from which to create the focus trap on mount; if a child is used
        //  instead of the `containerElements` prop, we'll get the child's related
        //  element when the trap renders and then is declared 'mounted'


        _this.focusTrapElements = props.containerElements || []; // now we remember what the currently focused element is, not relying on focus-trap

        _this.updatePreviousElement();

        return _this;
    }
    /** Update the previously focused element with the currently focused element. */


    _createClass(FocusTrap, [{
        key: "updatePreviousElement",
        value: function updatePreviousElement() {
            if (typeof document !== 'undefined') {
                this.previouslyFocusedElement = document.activeElement;
            }
        }
        /** Returns focus to the element that had focus when the trap was activated. */

    }, {
        key: "returnFocus",
        value: function returnFocus() {
            if (this.previouslyFocusedElement && this.previouslyFocusedElement.focus) {
                this.previouslyFocusedElement.focus();
            }
        }
    }, {
        key: "setupFocusTrap",
        value: function setupFocusTrap() {
            if (!this.focusTrap) {
                var focusTrapElementDOMNodes = this.focusTrapElements.map( // NOTE: `findDOMNode()` does not support CSS selectors; it'll just return
                    //  a new text node with the text wrapped in it instead of treating the
                    //  string as a selector and resolving it to a node in the DOM
                    reactDom__default.findDOMNode);
                var nodesExist = focusTrapElementDOMNodes.some(Boolean);

                if (nodesExist) {
                    // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop
                    this.focusTrap = this.props._createFocusTrap(focusTrapElementDOMNodes, this.tailoredFocusTrapOptions);

                    if (this.props.active) {
                        this.focusTrap.activate();
                    }

                    if (this.props.paused) {
                        this.focusTrap.pause();
                    }
                }
            }
        }
    }, {
        key: "componentDidMount",
        value: function componentDidMount() {
            this.setupFocusTrap();
        }
    }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
            if (this.focusTrap) {
                if (prevProps.containerElements !== this.props.containerElements) {
                    this.focusTrap.updateContainerElements(this.props.containerElements);
                }

                if (prevProps.active && !this.props.active) {
                    // NOTE: we never let the trap return the focus since we do that ourselves
                    this.focusTrap.deactivate({
                        returnFocus: false
                    });

                    if (this.returnFocusOnDeactivate) {
                        this.returnFocus();
                    }

                    return; // un/pause does nothing on an inactive trap
                }

                if (!prevProps.active && this.props.active) {
                    this.updatePreviousElement();
                    this.focusTrap.activate();
                }

                if (prevProps.paused && !this.props.paused) {
                    this.focusTrap.unpause();
                } else if (!prevProps.paused && this.props.paused) {
                    this.focusTrap.pause();
                }
            } else if (prevProps.containerElements !== this.props.containerElements) {
                this.focusTrapElements = this.props.containerElements;
                this.setupFocusTrap();
            }
        }
    }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
            if (this.focusTrap) {
                // NOTE: we never let the trap return the focus since we do that ourselves
                this.focusTrap.deactivate({
                    returnFocus: false
                });
            }

            if (this.returnFocusOnDeactivate) {
                this.returnFocus();
            }
        }
    }, {
        key: "render",
        value: function render() {
            var _this2 = this;

            var child = this.props.children ? React__default.Children.only(this.props.children) : undefined;

            if (child) {
                var composedRefCallback = function composedRefCallback(element) {
                    var containerElements = _this2.props.containerElements;

                    if (child) {
                        if (typeof child.ref === 'function') {
                            child.ref(element);
                        } else if (child.ref) {
                            child.ref.current = element;
                        }
                    }

                    _this2.focusTrapElements = containerElements ? containerElements : [element];
                };

                var childWithRef = React__default.cloneElement(child, {
                    ref: composedRefCallback
                });
                return childWithRef;
            }

            return null;
        }
    }]);

    return FocusTrap;
}(React__default.Component); // support server-side rendering where `Element` will not be defined


var ElementType = typeof Element === 'undefined' ? Function : Element;
FocusTrap.propTypes = {
    active: PropTypes.bool,
    paused: PropTypes.bool,
    focusTrapOptions: PropTypes.shape({
        onActivate: PropTypes.func,
        onDeactivate: PropTypes.func,
        initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),
        fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),
        escapeDeactivates: PropTypes.bool,
        clickOutsideDeactivates: PropTypes.bool,
        returnFocusOnDeactivate: PropTypes.bool,
        setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),
        allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
        preventScroll: PropTypes.bool
    }),
    containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),
    children: PropTypes.oneOfType([PropTypes.element, // React element
        PropTypes.instanceOf(ElementType) // DOM element
    ]) // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't
    //  specify it here. It's expected to be set to the function returned from
    //  require('focus-trap'), or one with a compatible interface.

};
FocusTrap.defaultProps = {
    active: true,
    paused: false,
    focusTrapOptions: {},
    _createFocusTrap: createFocusTrap$1
};
var focusTrapReact = FocusTrap;

var PREFIX$i = "vds-modal";
var MODAL_NOT_SCROLLABLE_CLASSNAME = "vds-modal-not-scrollable";
var SCROLL_LOCK_CLASSNAME = "vds-scroll-lock";
/**
 * Modals present content in a layer above the page to inform users about a task, convey important information, or require a decision.
 * They can be dismissed using the `esc` key or by clicking outside.
 * Use Modals sparingly to avoid interrupting workflows too frequently.
 */

var Modal = function(_a) {
    var _b;

    var children = _a.children,
        label = _a.label,
        onClose = _a.onClose,
        _c = _a.closeLabel,
        closeLabel = _c === void 0 ? "Close Modal" : _c,
        _d = _a.open,
        open = _d === void 0 ? false : _d,
        _e = _a.scrollable,
        scrollable = _e === void 0 ? true : _e; // Close when clicked outside

    var modalRef = React.useRef(null);
    useOnClickOutside(modalRef, onClose); // Close when `esc` is pressed

    useOnEscKeyDown(onClose); // Lock and unlock scrolling when open / closed

    React.useEffect(function() {
        var _a;

        var currentPageClassList = (_a = document === null || document === void 0 ? void 0 : document.querySelector("html")) === null || _a === void 0 ? void 0 : _a.classList;

        if (currentPageClassList) {
            open ? currentPageClassList.add(SCROLL_LOCK_CLASSNAME) : currentPageClassList.remove(SCROLL_LOCK_CLASSNAME);
        }

        return function() {
            return currentPageClassList === null || currentPageClassList === void 0 ? void 0 : currentPageClassList.remove(SCROLL_LOCK_CLASSNAME);
        };
    }, [open]);
    var className = classnames(PREFIX$i, (_b = {}, _b[MODAL_NOT_SCROLLABLE_CLASSNAME] = !scrollable, _b));
    var closeIcon = /*#__PURE__*/ React__default.createElement(Icon, {
        color: "silver",
        hidden: true
    }, /*#__PURE__*/ React__default.createElement("svg", {
        viewBox: "0 0 32 32"
    }, /*#__PURE__*/ React__default.createElement("path", {
        d: "M14.586 16L7.293 8.707a1 1 0 0 1 1.414-1.414L16 14.586l7.293-7.293a1 1 0 0 1 1.414 1.414L17.414 16l7.293 7.293a1 1 0 0 1-1.414 1.414L16 17.414l-7.293 7.293a1 1 0 1 1-1.414-1.414L14.586 16z",
        fillRule: "nonzero"
    })));
    var closeButton = /*#__PURE__*/ React__default.createElement("div", {
        className: PREFIX$i + "__close-button"
    }, /*#__PURE__*/ React__default.createElement(RoundButton, {
        label: closeLabel,
        icon: closeIcon,
        onClick: onClose,
        small: true,
        variant: "minimal"
    }));
    var contentClass = PREFIX$i + "__content";
    /* eslint-disable jsx-a11y/no-noninteractive-element-interactions */

    return /*#__PURE__*/ React__default.createElement(React__default.Fragment, null, /*#__PURE__*/ reactDom.createPortal(open && /*#__PURE__*/ React__default.createElement(focusTrapReact, {
        focusTrapOptions: {
            initialFocus: "." + contentClass
        }
    }, /*#__PURE__*/ React__default.createElement("aside", {
        "aria-label": label,
        "aria-modal": "true",
        className: PREFIX$i + "__blanket",
        role: "dialog"
    }, /*#__PURE__*/ React__default.createElement("div", {
        className: className,
        ref: modalRef
    }, closeButton, /*#__PURE__*/ React__default.createElement("div", {
        className: contentClass,
        tabIndex: 0
    }, children)))), document.body));
};

function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }

    return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

var _extends_1 = createCommonjsModule(function(module) {
    function _extends() {
        module.exports = _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];

                for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        target[key] = source[key];
                    }
                }
            }

            return target;
        };

        return _extends.apply(this, arguments);
    }

    module.exports = _extends;
});

function _assertThisInitialized$1(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
}

var assertThisInitialized = _assertThisInitialized$1;

var setPrototypeOf = createCommonjsModule(function(module) {
    function _setPrototypeOf(o, p) {
        module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
        };

        return _setPrototypeOf(o, p);
    }

    module.exports = _setPrototypeOf;
});

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
}

var inheritsLoose = _inheritsLoose;

function _defineProperty$1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }

    return obj;
}

var defineProperty = _defineProperty$1;

var toStr = Object.prototype.toString;

var isArguments = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === '[object Arguments]';
    if (!isArgs) {
        isArgs = str !== '[object Array]' &&
            value !== null &&
            typeof value === 'object' &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            toStr.call(value.callee) === '[object Function]';
    }
    return isArgs;
};

var keysShim;
if (!Object.keys) {
    // modified from https://github.com/es-shims/es5-shim
    var has = Object.prototype.hasOwnProperty;
    var toStr$1 = Object.prototype.toString;
    var isArgs = isArguments; // eslint-disable-line global-require
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({
        toString: null
    }, 'toString');
    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
    };
    var hasAutomationEqualityBug = (function() {
        /* global window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    try {
                        equalsConstructorPrototype(window[k]);
                    } catch (e) {
                        return true;
                    }
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
        /* global window */
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
        }
        try {
            return equalsConstructorPrototype(o);
        } catch (e) {
            return false;
        }
    };

    keysShim = function keys(object) {
        var isObject = object !== null && typeof object === 'object';
        var isFunction = toStr$1.call(object) === '[object Function]';
        var isArguments = isArgs(object);
        var isString = isObject && toStr$1.call(object) === '[object String]';
        var theKeys = [];

        if (!isObject && !isFunction && !isArguments) {
            throw new TypeError('Object.keys called on a non-object');
        }

        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
                theKeys.push(String(i));
            }
        }

        if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
                theKeys.push(String(j));
            }
        } else {
            for (var name in object) {
                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                    theKeys.push(String(name));
                }
            }
        }

        if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

            for (var k = 0; k < dontEnums.length; ++k) {
                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                    theKeys.push(dontEnums[k]);
                }
            }
        }
        return theKeys;
    };
}
var implementation = keysShim;

var slice = Array.prototype.slice;


var origKeys = Object.keys;
var keysShim$1 = origKeys ? function keys(o) {
    return origKeys(o);
} : implementation;

var originalKeys = Object.keys;

keysShim$1.shim = function shimObjectKeys() {
    if (Object.keys) {
        var keysWorksWithArguments = (function() {
            // Safari 5.0 bug
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
        }(1, 2));
        if (!keysWorksWithArguments) {
            Object.keys = function keys(object) { // eslint-disable-line func-name-matching
                if (isArguments(object)) {
                    return originalKeys(slice.call(object));
                }
                return originalKeys(object);
            };
        }
    } else {
        Object.keys = keysShim$1;
    }
    return Object.keys || keysShim$1;
};

var objectKeys = keysShim$1;

/* eslint complexity: [2, 18], max-statements: [2, 33] */
var shams = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }

    var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }

    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }

    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }

    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
        return false;
    } // eslint-disable-line no-restricted-syntax
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }

    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }

    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }

    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }

    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }

    return true;
};

var origSymbol = commonjsGlobal.Symbol;


var hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }

    return shams();
};

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice$1 = Array.prototype.slice;
var toStr$2 = Object.prototype.toString;
var funcType = '[object Function]';

var implementation$1 = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr$2.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice$1.call(arguments, 1);

    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice$1.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice$1.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

var functionBind = Function.prototype.bind || implementation$1;

var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

var undefined$1;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
    try {
        $gOPD({}, '');
    } catch (e) {
        $gOPD = null; // this is IE 8, which has a broken gOPD
    }
}

var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ?
    (function() {
        try {
            // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
            arguments.callee; // IE 8 does not throw here
            return throwTypeError;
        } catch (calleeThrows) {
            try {
                // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                return $gOPD(arguments, 'callee').get;
            } catch (gOPDthrows) {
                return throwTypeError;
            }
        }
    }()) :
    throwTypeError;

var hasSymbols$1 = hasSymbols();

var getProto = Object.getPrototypeOf || function(x) {
    return x.__proto__;
}; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

var INTRINSICS = {
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
    '%AsyncFromSyncIteratorPrototype%': undefined$1,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%eval%': eval, // eslint-disable-line no-eval
    '%EvalError%': EvalError,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
    '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    '%RangeError%': RangeError,
    '%ReferenceError%': ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols$1 ? getProto('' [Symbol.iterator]()) : undefined$1,
    '%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    '%URIError%': URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
};

var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen) {
            value = getProto(gen.prototype);
        }
    }

    INTRINSICS[name] = value;

    return value;
};

var LEGACY_ALIASES = {
    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    '%ArrayPrototype%': ['Array', 'prototype'],
    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    '%BooleanPrototype%': ['Boolean', 'prototype'],
    '%DataViewPrototype%': ['DataView', 'prototype'],
    '%DatePrototype%': ['Date', 'prototype'],
    '%ErrorPrototype%': ['Error', 'prototype'],
    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    '%FunctionPrototype%': ['Function', 'prototype'],
    '%Generator%': ['GeneratorFunction', 'prototype'],
    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    '%JSONParse%': ['JSON', 'parse'],
    '%JSONStringify%': ['JSON', 'stringify'],
    '%MapPrototype%': ['Map', 'prototype'],
    '%NumberPrototype%': ['Number', 'prototype'],
    '%ObjectPrototype%': ['Object', 'prototype'],
    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    '%PromisePrototype%': ['Promise', 'prototype'],
    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    '%Promise_all%': ['Promise', 'all'],
    '%Promise_reject%': ['Promise', 'reject'],
    '%Promise_resolve%': ['Promise', 'resolve'],
    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    '%RegExpPrototype%': ['RegExp', 'prototype'],
    '%SetPrototype%': ['Set', 'prototype'],
    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    '%StringPrototype%': ['String', 'prototype'],
    '%SymbolPrototype%': ['Symbol', 'prototype'],
    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    '%URIErrorPrototype%': ['URIError', 'prototype'],
    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
    '%WeakSetPrototype%': ['WeakSet', 'prototype']
};



var $concat = functionBind.call(Function.call, Array.prototype.concat);
var $spliceApply = functionBind.call(Function.apply, Array.prototype.splice);
var $replace = functionBind.call(Function.call, String.prototype.replace);
var $strSlice = functionBind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (src(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }

    if (src(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }

        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }

    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

var getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }

    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;

    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
    }

    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if (
            (
                (first === '"' || first === "'" || first === '`') ||
                (last === '"' || last === "'" || last === '`')
            ) &&
            first !== last
        ) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }

        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';

        if (src(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined$1;
            }
            if ($gOPD && (i + 1) >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;

                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = src(value, part);
                value = value[part];
            }

            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};

var callBind = createCommonjsModule(function(module) {




    var $apply = getIntrinsic('%Function.prototype.apply%');
    var $call = getIntrinsic('%Function.prototype.call%');
    var $reflectApply = getIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);

    var $gOPD = getIntrinsic('%Object.getOwnPropertyDescriptor%', true);
    var $defineProperty = getIntrinsic('%Object.defineProperty%', true);
    var $max = getIntrinsic('%Math.max%');

    if ($defineProperty) {
        try {
            $defineProperty({}, 'a', {
                value: 1
            });
        } catch (e) {
            // IE 8 has a broken defineProperty
            $defineProperty = null;
        }
    }

    module.exports = function callBind(originalFunction) {
        var func = $reflectApply(functionBind, $call, arguments);
        if ($gOPD && $defineProperty) {
            var desc = $gOPD(func, 'length');
            if (desc.configurable) {
                // original length, plus the receiver, minus any additional arguments (after the receiver)
                $defineProperty(
                    func,
                    'length', {
                        value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                    }
                );
            }
        }
        return func;
    };

    var applyBind = function applyBind() {
        return $reflectApply(functionBind, $apply, arguments);
    };

    if ($defineProperty) {
        $defineProperty(module.exports, 'apply', {
            value: applyBind
        });
    } else {
        module.exports.apply = applyBind;
    }
});

var $indexOf = callBind(getIntrinsic('String.prototype.indexOf'));

var callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = getIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBind(intrinsic);
    }
    return intrinsic;
};

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';


var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
        return false;
    }
    return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) {
        return true;
    }
    return value !== null &&
        typeof value === 'object' &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        $toString(value) !== '[object Array]' &&
        $toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function() {
    return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

var hasSymbols$2 = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr$3 = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function(fn) {
    return typeof fn === 'function' && toStr$3.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function() {
    var obj = {};
    try {
        origDefineProperty(obj, 'x', {
            enumerable: false,
            value: obj
        });
        // eslint-disable-next-line no-unused-vars, no-restricted-syntax
        for (var _ in obj) { // jscs:ignore disallowUnusedVariables
            return false;
        }
        return obj.x === obj;
    } catch (e) { /* this is IE 8. */
        return false;
    }
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty$1 = function(object, name, value, predicate) {
    if (name in object && (!isFunction(predicate) || !predicate())) {
        return;
    }
    if (supportsDescriptors) {
        origDefineProperty(object, name, {
            configurable: true,
            enumerable: false,
            value: value,
            writable: true
        });
    } else {
        object[name] = value;
    }
};

var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = objectKeys(map);
    if (hasSymbols$2) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
    }
    for (var i = 0; i < props.length; i += 1) {
        defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
    }
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

var defineProperties_1 = defineProperties;

var numberIsNaN = function(value) {
    return value !== value;
};

var implementation$2 = function is(a, b) {
    if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
    }
    if (a === b) {
        return true;
    }
    if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
    }
    return false;
};

var polyfill = function getPolyfill() {
    return typeof Object.is === 'function' ? Object.is : implementation$2;
};

var shim = function shimObjectIs() {
    var polyfill$1 = polyfill();
    defineProperties_1(Object, {
        is: polyfill$1
    }, {
        is: function testObjectIs() {
            return Object.is !== polyfill$1;
        }
    });
    return polyfill$1;
};

var polyfill$1 = callBind(polyfill(), Object);

defineProperties_1(polyfill$1, {
    getPolyfill: polyfill,
    implementation: implementation$2,
    shim: shim
});

var objectIs = polyfill$1;

var hasSymbols$3 = hasSymbols();
var hasToStringTag$1 = hasSymbols$3 && typeof Symbol.toStringTag === 'symbol';
var has$1;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag$1) {
    has$1 = callBound('Object.prototype.hasOwnProperty');
    $exec = callBound('RegExp.prototype.exec');
    isRegexMarker = {};

    var throwRegexMarker = function() {
        throw isRegexMarker;
    };
    badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
    };

    if (typeof Symbol.toPrimitive === 'symbol') {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
}

var $toString$1 = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

var isRegex = hasToStringTag$1
    // eslint-disable-next-line consistent-return
    ?
    function isRegex(value) {
        if (!value || typeof value !== 'object') {
            return false;
        }

        var descriptor = gOPD(value, 'lastIndex');
        var hasLastIndexDataProperty = descriptor && has$1(descriptor, 'value');
        if (!hasLastIndexDataProperty) {
            return false;
        }

        try {
            $exec(value, badStringifier);
        } catch (e) {
            return e === isRegexMarker;
        }
    } :
    function isRegex(value) {
        // In older browsers, typeof regex incorrectly returns 'function'
        if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
            return false;
        }

        return $toString$1(value) === regexClass;
    };

var $Object = Object;
var $TypeError$1 = TypeError;

var implementation$3 = function flags() {
    if (this != null && this !== $Object(this)) {
        throw new $TypeError$1('RegExp.prototype.flags getter called on non-object');
    }
    var result = '';
    if (this.global) {
        result += 'g';
    }
    if (this.ignoreCase) {
        result += 'i';
    }
    if (this.multiline) {
        result += 'm';
    }
    if (this.dotAll) {
        result += 's';
    }
    if (this.unicode) {
        result += 'u';
    }
    if (this.sticky) {
        result += 'y';
    }
    return result;
};

var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD$1 = Object.getOwnPropertyDescriptor;
var $TypeError$2 = TypeError;

var polyfill$2 = function getPolyfill() {
    if (!supportsDescriptors$1) {
        throw new $TypeError$2('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
    }
    if ((/a/mig).flags === 'gim') {
        var descriptor = $gOPD$1(RegExp.prototype, 'flags');
        if (descriptor && typeof descriptor.get === 'function' && typeof(/a/).dotAll === 'boolean') {
            return descriptor.get;
        }
    }
    return implementation$3;
};

var supportsDescriptors$2 = defineProperties_1.supportsDescriptors;

var gOPD$1 = Object.getOwnPropertyDescriptor;
var defineProperty$2 = Object.defineProperty;
var TypeErr = TypeError;
var getProto$1 = Object.getPrototypeOf;
var regex = /a/;

var shim$1 = function shimFlags() {
    if (!supportsDescriptors$2 || !getProto$1) {
        throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
    }
    var polyfill = polyfill$2();
    var proto = getProto$1(regex);
    var descriptor = gOPD$1(proto, 'flags');
    if (!descriptor || descriptor.get !== polyfill) {
        defineProperty$2(proto, 'flags', {
            configurable: true,
            enumerable: false,
            get: polyfill
        });
    }
    return polyfill;
};

var flagsBound = callBind(implementation$3);

defineProperties_1(flagsBound, {
    getPolyfill: polyfill$2,
    implementation: implementation$3,
    shim: shim$1
});

var regexp_prototype_flags = flagsBound;

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
    try {
        getDay.call(value);
        return true;
    } catch (e) {
        return false;
    }
};

var toStr$4 = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag$2 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var isDateObject = function isDateObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    return hasToStringTag$2 ? tryDateObject(value) : toStr$4.call(value) === dateClass;
};

var getTime = Date.prototype.getTime;

function deepEqual(actual, expected, options) {
    var opts = options || {};

    // 7.1. All identical values are equivalent, as determined by ===.
    if (opts.strict ? objectIs(actual, expected) : actual === expected) {
        return true;
    }

    // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
    if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
        return opts.strict ? objectIs(actual, expected) : actual == expected;
    }

    /*
     * 7.4. For all other Object pairs, including Array objects, equivalence is
     * determined by having the same number of owned properties (as verified
     * with Object.prototype.hasOwnProperty.call), the same set of keys
     * (although not necessarily the same order), equivalent values for every
     * corresponding key, and an identical 'prototype' property. Note: this
     * accounts for both named and indexed properties on Arrays.
     */
    // eslint-disable-next-line no-use-before-define
    return objEquiv(actual, expected, opts);
}

function isUndefinedOrNull(value) {
    return value === null || value === undefined;
}

function isBuffer(x) {
    if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
        return false;
    }
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number') {
        return false;
    }
    return true;
}

function objEquiv(a, b, opts) {
    /* eslint max-statements: [2, 50] */
    var i, key;
    if (typeof a !== typeof b) {
        return false;
    }
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
        return false;
    }

    // an identical 'prototype' property.
    if (a.prototype !== b.prototype) {
        return false;
    }

    if (isArguments$1(a) !== isArguments$1(b)) {
        return false;
    }

    var aIsRegex = isRegex(a);
    var bIsRegex = isRegex(b);
    if (aIsRegex !== bIsRegex) {
        return false;
    }
    if (aIsRegex || bIsRegex) {
        return a.source === b.source && regexp_prototype_flags(a) === regexp_prototype_flags(b);
    }

    if (isDateObject(a) && isDateObject(b)) {
        return getTime.call(a) === getTime.call(b);
    }

    var aIsBuffer = isBuffer(a);
    var bIsBuffer = isBuffer(b);
    if (aIsBuffer !== bIsBuffer) {
        return false;
    }
    if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
        if (a.length !== b.length) {
            return false;
        }
        for (i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }

    if (typeof a !== typeof b) {
        return false;
    }

    try {
        var ka = objectKeys(a);
        var kb = objectKeys(b);
    } catch (e) { // happens when one is a string literal and the other isn't
        return false;
    }
    // having the same number of owned properties (keys incorporates hasOwnProperty)
    if (ka.length !== kb.length) {
        return false;
    }

    // the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    // ~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i]) {
            return false;
        }
    }
    // equivalent values for every corresponding key, and ~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) {
            return false;
        }
    }

    return true;
}

var deepEqual_1 = deepEqual;

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function() {
    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
            return 1;
        }
    }
    return 0;
}();

function microtaskDebounce(fn) {
    var called = false;
    return function() {
        if (called) {
            return;
        }
        called = true;
        window.Promise.resolve().then(function() {
            called = false;
            fn();
        });
    };
}

function taskDebounce(fn) {
    var scheduled = false;
    return function() {
        if (!scheduled) {
            scheduled = true;
            setTimeout(function() {
                scheduled = false;
                fn();
            }, timeoutDuration);
        }
    };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
 * Create a debounced version of a method, that's asynchronously deferred
 * but called in the minimum time possible.
 *
 * @method
 * @memberof Popper.Utils
 * @argument {Function} fn
 * @returns {Function}
 */
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$1(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
        return [];
    }
    // NOTE: 1 DOM access here
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
    if (element.nodeName === 'HTML') {
        return element;
    }
    return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
        return document.body;
    }

    switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
            return element.ownerDocument.body;
        case '#document':
            return element.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
    }

    return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
    if (version === 11) {
        return isIE11;
    }
    if (version === 10) {
        return isIE10;
    }
    return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
    if (!element) {
        return document.documentElement;
    }

    var noOffsetParent = isIE(10) ? document.body : null;

    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent || null;
    // Skip hidden elements which don't have an offsetParent
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
    }

    // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
    }

    return offsetParent;
}

function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
        return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
    if (node.parentNode !== null) {
        return getRoot(node.parentNode);
    }

    return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
            return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
    } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
    }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
        var html = element.ownerDocument.documentElement;
        var scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
    }

    return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);

    return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
    };
}

var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
};

var createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();





var defineProperty$3 = function(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }

    return obj;
};

var _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
    return _extends$1({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
    });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    try {
        if (isIE(10)) {
            rect = element.getBoundingClientRect();
            var scrollTop = getScroll(element, 'top');
            var scrollLeft = getScroll(element, 'left');
            rect.top += scrollTop;
            rect.left += scrollLeft;
            rect.bottom += scrollTop;
            rect.right += scrollLeft;
        } else {
            rect = element.getBoundingClientRect();
        }
    } catch (e) {}

    var result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.width;
    var height = sizes.height || element.clientHeight || result.height;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
        var styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
    }

    return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth);

    // In cases where the parent is fixed, we must ignore negative scroll in offset calc
    if (fixedPosition && isHTML) {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
        var marginTop = parseFloat(styles.marginTop);
        var marginLeft = parseFloat(styles.marginLeft);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
    }

    return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

    var offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width: width,
        height: height
    };

    return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
        return false;
    }
    return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
    }
    return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    // NOTE: 1 DOM access here

    var boundaries = {
        top: 0,
        left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

    // Handle viewport case
    if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
        // Handle other cases based on DOM element used as boundaries
        var boundariesNode = void 0;
        if (boundariesElement === 'scrollParent') {
            boundariesNode = getScrollParent(getParentNode(reference));
            if (boundariesNode.nodeName === 'BODY') {
                boundariesNode = popper.ownerDocument.documentElement;
            }
        } else if (boundariesElement === 'window') {
            boundariesNode = popper.ownerDocument.documentElement;
        } else {
            boundariesNode = boundariesElement;
        }

        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
            var _getWindowSizes = getWindowSizes(popper.ownerDocument),
                height = _getWindowSizes.height,
                width = _getWindowSizes.width;

            boundaries.top += offsets.top - offsets.marginTop;
            boundaries.bottom = height + offsets.top;
            boundaries.left += offsets.left - offsets.marginLeft;
            boundaries.right = width + offsets.left;
        } else {
            // for all the other DOM elements, this one is good
            boundaries = offsets;
        }
    }

    // Add paddings
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

    return boundaries;
}

function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
        return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
        top: {
            width: boundaries.width,
            height: refRect.top - boundaries.top
        },
        right: {
            width: boundaries.right - refRect.right,
            height: boundaries.height
        },
        bottom: {
            width: boundaries.width,
            height: boundaries.bottom - refRect.bottom
        },
        left: {
            width: refRect.left - boundaries.left,
            height: boundaries.height
        }
    };

    var sortedAreas = Object.keys(rects).map(function(key) {
        return _extends$1({
            key: key
        }, rects[key], {
            area: getArea(rects[key])
        });
    }).sort(function(a, b) {
        return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function(_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
    };
    return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
    var hash = {
        left: 'right',
        right: 'left',
        bottom: 'top',
        top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
    });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
        return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex$1(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
        return arr.findIndex(function(cur) {
            return cur[prop] === value;
        });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function(obj) {
        return obj[prop] === value;
    });
    return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex$1(modifiers, 'name', ends));

    modifiersToRun.forEach(function(modifier) {
        if (modifier['function']) {
            // eslint-disable-line dot-notation
            console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction$1(fn)) {
            // Add properties to offsets to make them a complete clientRect object
            // we do this before each modifier to make sure the previous one doesn't
            // mess with these values
            data.offsets.popper = getClientRect(data.offsets.popper);
            data.offsets.reference = getClientRect(data.offsets.reference);

            data = fn(data, modifier);
        }
    });

    return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
        return;
    }

    var data = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: false,
        offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    data.positionFixed = this.options.positionFixed;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
        this.state.isCreated = true;
        this.options.onCreate(data);
    } else {
        this.options.onUpdate(data);
    }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function(_ref) {
        var name = _ref.name,
            enabled = _ref.enabled;
        return enabled && name === modifierName;
    });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var toCheck = prefix ? '' + prefix + upperProp : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
            return toCheck;
        }
    }
    return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
        this.popper.removeAttribute('x-placement');
        this.popper.style.position = '';
        this.popper.style.top = '';
        this.popper.style.left = '';
        this.popper.style.right = '';
        this.popper.style.bottom = '';
        this.popper.style.willChange = '';
        this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicitly asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
        this.popper.parentNode.removeChild(this.popper);
    }
    return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
        passive: true
    });

    if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, {
        passive: true
    });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
    if (!this.state.eventsEnabled) {
        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function(target) {
        target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
    if (this.state.eventsEnabled) {
        cancelAnimationFrame(this.scheduleUpdate);
        this.state = removeEventListeners(this.reference, this.state);
    }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
    Object.keys(styles).forEach(function(prop) {
        var unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
            unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
    });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function(prop) {
        var value = attributes[prop];
        if (value !== false) {
            element.setAttribute(prop, attributes[prop]);
        } else {
            element.removeAttribute(prop);
        }
    });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
        setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, {
        position: options.positionFixed ? 'fixed' : 'absolute'
    });

    return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
        return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);

    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;

    return {
        left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
        top: verticalToInteger(popper.top),
        bottom: verticalToInteger(popper.bottom),
        right: horizontalToInteger(popper.right)
    };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
        return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
        console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
        position: popper.position
    };

    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
        // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
        // and not the bottom of the html element
        if (offsetParent.nodeName === 'HTML') {
            top = -offsetParent.clientHeight + offsets.bottom;
        } else {
            top = -offsetParentRect.height + offsets.bottom;
        }
    } else {
        top = offsets.top;
    }
    if (sideB === 'right') {
        if (offsetParent.nodeName === 'HTML') {
            left = -offsetParent.clientWidth + offsets.right;
        } else {
            left = -offsetParentRect.width + offsets.right;
        }
    } else {
        left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
        styles[sideA] = 0;
        styles[sideB] = 0;
        styles.willChange = 'transform';
    } else {
        // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
        var invertTop = sideA === 'bottom' ? -1 : 1;
        var invertLeft = sideB === 'right' ? -1 : 1;
        styles[sideA] = top * invertTop;
        styles[sideB] = left * invertLeft;
        styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
        'x-placement': data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends$1({}, attributes, data.attributes);
    data.styles = _extends$1({}, styles, data.styles);
    data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);

    return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function(_ref) {
        var name = _ref.name;
        return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function(modifier) {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
        var _requesting = '`' + requestingName + '`';
        var requested = '`' + requestedName + '`';
        console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
    var _data$offsets$arrow;

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
        arrowElement = data.instance.popper.querySelector(arrowElement);

        // if arrowElement is not found, don't run the modifier
        if (!arrowElement) {
            return data;
        }
    } else {
        // if the arrowElement isn't a query selector we must check that the
        // provided DOM node is child of its popper node
        if (!data.instance.popper.contains(arrowElement)) {
            console.warn('WARNING: `arrow.element` must be child of its popper element!');
            return data;
        }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$3(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$3(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

    return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
    if (variation === 'end') {
        return 'start';
    } else if (variation === 'start') {
        return 'end';
    }
    return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
        return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
        case BEHAVIORS.FLIP:
            flipOrder = [placement, placementOpposite];
            break;
        case BEHAVIORS.CLOCKWISE:
            flipOrder = clockwise(placement);
            break;
        case BEHAVIORS.COUNTERCLOCKWISE:
            flipOrder = clockwise(placement, true);
            break;
        default:
            flipOrder = options.behavior;
    }

    flipOrder.forEach(function(step, index) {
        if (placement !== step || flipOrder.length === index + 1) {
            return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        var popperOffsets = data.offsets.popper;
        var refOffsets = data.offsets.reference;

        // using floor because the reference offsets may contain decimals we are not going to consider here
        var floor = Math.floor;
        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

        // flip the variation if required
        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

        // flips variation if reference element overflows boundaries
        var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

        // flips variation if popper content overflows boundaries
        var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

        var flippedVariation = flippedVariationByRef || flippedVariationByContent;

        if (overlapsRef || overflowsBoundaries || flippedVariation) {
            // this boolean to detect any flip loop
            data.flipped = true;

            if (overlapsRef || overflowsBoundaries) {
                placement = flipOrder[index + 1];
            }

            if (flippedVariation) {
                variation = getOppositeVariation(variation);
            }

            data.placement = placement + (variation ? '-' + variation : '');

            // this object contains `position`, we want to preserve it along with
            // any additional property we may add in the future
            data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

            data = runModifiers(data.instance.modifiers, data, 'flip');
        }
    });
    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
        data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
        return str;
    }

    if (unit.indexOf('%') === 0) {
        var element = void 0;
        switch (unit) {
            case '%p':
                element = popperOffsets;
                break;
            case '%':
            case '%r':
            default:
                element = referenceOffsets;
        }

        var rect = getClientRect(element);
        return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
        // if is a vh or vw, we calculate the size based on the viewport
        var size = void 0;
        if (unit === 'vh') {
            size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        } else {
            size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        }
        return size / 100 * value;
    } else {
        // if is an explicit pixel unit, we get rid of the unit and keep the value
        // if is an implicit unit, it's px, and we return just the value
        return value;
    }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function(frag) {
        return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function(frag) {
        return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
        console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function(op, index) {
        // Most of the units rely on the orientation of the popper
        var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
        var mergeWithPrevious = false;
        return op
            // This aggregates any `+` or `-` sign that aren't considered operators
            // e.g.: 10 + +5 => [10, +, +5]
            .reduce(function(a, b) {
                if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
                    a[a.length - 1] = b;
                    mergeWithPrevious = true;
                    return a;
                } else if (mergeWithPrevious) {
                    a[a.length - 1] += b;
                    mergeWithPrevious = false;
                    return a;
                } else {
                    return a.concat(b);
                }
            }, [])
            // Here we convert the string values into number values (in px)
            .map(function(str) {
                return toValue(str, measurement, popperOffsets, referenceOffsets);
            });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function(op, index) {
        op.forEach(function(frag, index2) {
            if (isNumeric(frag)) {
                offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
            }
        });
    });
    return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
        offsets = [+offset, 0];
    } else {
        offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
        popper.top += offsets[0];
        popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
        popper.top += offsets[0];
        popper.left += offsets[1];
    } else if (basePlacement === 'top') {
        popper.left += offsets[0];
        popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
        popper.left += offsets[0];
        popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
        boundariesElement = getOffsetParent(boundariesElement);
    }

    // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];

    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

    // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;

    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
        primary: function primary(placement) {
            var value = popper[placement];
            if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                value = Math.max(popper[placement], boundaries[placement]);
            }
            return defineProperty$3({}, placement, value);
        },
        secondary: function secondary(placement) {
            var mainSide = placement === 'right' ? 'left' : 'top';
            var value = popper[mainSide];
            if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
            }
            return defineProperty$3({}, mainSide, value);
        }
    };

    order.forEach(function(placement) {
        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
        popper = _extends$1({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
        var _data$offsets = data.offsets,
            reference = _data$offsets.reference,
            popper = _data$offsets.popper;

        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
        var side = isVertical ? 'left' : 'top';
        var measurement = isVertical ? 'width' : 'height';

        var shiftOffsets = {
            start: defineProperty$3({}, side, reference[side]),
            end: defineProperty$3({}, side, reference[side] + reference[measurement] - popper[measurement])
        };

        data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
        return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function(modifier) {
        return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === true) {
            return data;
        }

        data.hide = true;
        data.attributes['x-out-of-boundaries'] = '';
    } else {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === false) {
            return data;
        }

        data.hide = false;
        data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ['left', 'right', 'top', 'bottom'],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper. This makes sure the popper always has a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier. Can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations)
         */
        behavior: 'flip',
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position.
         * The popper will never be placed outside of the defined boundaries
         * (except if `keepTogether` is enabled)
         */
        boundariesElement: 'viewport',
        /**
         * @prop {Boolean} flipVariations=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the reference element overlaps its boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariations: false,
        /**
         * @prop {Boolean} flipVariationsByContent=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the popper element overlaps its reference boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: 'bottom',
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: undefined
    }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function() {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
        var _this = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck(this, Popper);

        this.scheduleUpdate = function() {
            return requestAnimationFrame(_this.update);
        };

        // make update() debounced, so that it only runs at most once-per-tick
        this.update = debounce(this.update.bind(this));

        // with {} we create a new object with the options inside it
        this.options = _extends$1({}, Popper.Defaults, options);

        // init state
        this.state = {
            isDestroyed: false,
            isCreated: false,
            scrollParents: []
        };

        // get reference and popper elements (allow jQuery wrappers)
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;

        // Deep merge modifiers options
        this.options.modifiers = {};
        Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function(name) {
            _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });

        // Refactoring modifiers' list (Object => Array)
        this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
                return _extends$1({
                    name: name
                }, _this.options.modifiers[name]);
            })
            // sort the modifiers by order
            .sort(function(a, b) {
                return a.order - b.order;
            });

        // modifiers have the ability to execute arbitrary code when Popper.js get inited
        // such code is executed in the same order of its modifier
        // they could add new properties to their options configuration
        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
        this.modifiers.forEach(function(modifierOptions) {
            if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {
                modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
            }
        });

        // fire the first update to position the popper in the right place
        this.update();

        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
            // setup event listeners, they will take care of update the position in specific situations
            this.enableEventListeners();
        }

        this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
        key: 'update',
        value: function update$$1() {
            return update.call(this);
        }
    }, {
        key: 'destroy',
        value: function destroy$$1() {
            return destroy.call(this);
        }
    }, {
        key: 'enableEventListeners',
        value: function enableEventListeners$$1() {
            return enableEventListeners.call(this);
        }
    }, {
        key: 'disableEventListeners',
        value: function disableEventListeners$$1() {
            return disableEventListeners.call(this);
        }

        /**
         * Schedules an update. It will run on the next UI update available.
         * @method scheduleUpdate
         * @memberof Popper
         */


        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */

    }]);
    return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

var key = '__global_unique_id__';

var gud = function() {
    return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
};

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function() {};

if (__DEV__) {
    var printWarning = function printWarning(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
            args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = 'Warning: ' +
            format.replace(/%s/g, function() {
                return args[argIndex++];
            });
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };

    warning = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
            args[key - 2] = arguments[key];
        }
        if (format === undefined) {
            throw new Error(
                '`warning(condition, format, ...args)` requires a warning ' +
                'message argument'
            );
        }
        if (!condition) {
            printWarning.apply(null, [format].concat(args));
        }
    };
}

var warning_1 = warning;

var implementation$4 = createCommonjsModule(function(module, exports) {

    exports.__esModule = true;



    var _react2 = _interopRequireDefault(React__default);



    var _propTypes2 = _interopRequireDefault(PropTypes);



    var _gud2 = _interopRequireDefault(gud);



    var _warning2 = _interopRequireDefault(warning_1);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var MAX_SIGNED_31_BIT_INT = 1073741823;

    // Inlined Object.is polyfill.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    function objectIs(x, y) {
        if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
        } else {
            return x !== x && y !== y;
        }
    }

    function createEventEmitter(value) {
        var handlers = [];
        return {
            on: function on(handler) {
                handlers.push(handler);
            },
            off: function off(handler) {
                handlers = handlers.filter(function(h) {
                    return h !== handler;
                });
            },
            get: function get() {
                return value;
            },
            set: function set(newValue, changedBits) {
                value = newValue;
                handlers.forEach(function(handler) {
                    return handler(value, changedBits);
                });
            }
        };
    }

    function onlyChild(children) {
        return Array.isArray(children) ? children[0] : children;
    }

    function createReactContext(defaultValue, calculateChangedBits) {
        var _Provider$childContex, _Consumer$contextType;

        var contextProp = '__create-react-context-' + (0, _gud2.default)() + '__';

        var Provider = function(_Component) {
            _inherits(Provider, _Component);

            function Provider() {
                var _temp, _this, _ret;

                _classCallCheck(this, Provider);

                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
            }

            Provider.prototype.getChildContext = function getChildContext() {
                var _ref;

                return _ref = {}, _ref[contextProp] = this.emitter, _ref;
            };

            Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
                if (this.props.value !== nextProps.value) {
                    var oldValue = this.props.value;
                    var newValue = nextProps.value;
                    var changedBits = void 0;

                    if (objectIs(oldValue, newValue)) {
                        changedBits = 0; // No change
                    } else {
                        changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
                        if (process.env.NODE_ENV !== 'production') {
                            (0, _warning2.default)((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
                        }

                        changedBits |= 0;

                        if (changedBits !== 0) {
                            this.emitter.set(nextProps.value, changedBits);
                        }
                    }
                }
            };

            Provider.prototype.render = function render() {
                return this.props.children;
            };

            return Provider;
        }(React__default.Component);

        Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

        var Consumer = function(_Component2) {
            _inherits(Consumer, _Component2);

            function Consumer() {
                var _temp2, _this2, _ret2;

                _classCallCheck(this, Consumer);

                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }

                return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
                    value: _this2.getValue()
                }, _this2.onUpdate = function(newValue, changedBits) {
                    var observedBits = _this2.observedBits | 0;
                    if ((observedBits & changedBits) !== 0) {
                        _this2.setState({
                            value: _this2.getValue()
                        });
                    }
                }, _temp2), _possibleConstructorReturn(_this2, _ret2);
            }

            Consumer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
                var observedBits = nextProps.observedBits;

                this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
                    :
                    observedBits;
            };

            Consumer.prototype.componentDidMount = function componentDidMount() {
                if (this.context[contextProp]) {
                    this.context[contextProp].on(this.onUpdate);
                }
                var observedBits = this.props.observedBits;

                this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
                    :
                    observedBits;
            };

            Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
                if (this.context[contextProp]) {
                    this.context[contextProp].off(this.onUpdate);
                }
            };

            Consumer.prototype.getValue = function getValue() {
                if (this.context[contextProp]) {
                    return this.context[contextProp].get();
                } else {
                    return defaultValue;
                }
            };

            Consumer.prototype.render = function render() {
                return onlyChild(this.props.children)(this.state.value);
            };

            return Consumer;
        }(React__default.Component);

        Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);


        return {
            Provider: Provider,
            Consumer: Consumer
        };
    }

    exports.default = createReactContext;
    module.exports = exports['default'];
});

var lib = createCommonjsModule(function(module, exports) {

    exports.__esModule = true;



    var _react2 = _interopRequireDefault(React__default);



    var _implementation2 = _interopRequireDefault(implementation$4);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    exports.default = _react2.default.createContext || _implementation2.default;
    module.exports = exports['default'];
});

var ManagerReferenceNodeContext = lib();
var ManagerReferenceNodeSetterContext = lib();

var Manager =
    /*#__PURE__*/
    function(_React$Component) {
        inheritsLoose(Manager, _React$Component);

        function Manager() {
            var _this;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

            defineProperty(assertThisInitialized(_this), "referenceNode", void 0);

            defineProperty(assertThisInitialized(_this), "setReferenceNode", function(newReferenceNode) {
                if (newReferenceNode && _this.referenceNode !== newReferenceNode) {
                    _this.referenceNode = newReferenceNode;

                    _this.forceUpdate();
                }
            });

            return _this;
        }

        var _proto = Manager.prototype;

        _proto.componentWillUnmount = function componentWillUnmount() {
            this.referenceNode = null;
        };

        _proto.render = function render() {
            return React.createElement(ManagerReferenceNodeContext.Provider, {
                value: this.referenceNode
            }, React.createElement(ManagerReferenceNodeSetterContext.Provider, {
                value: this.setReferenceNode
            }, this.props.children));
        };

        return Manager;
    }(React.Component);

/**
 * Takes an argument and if it's an array, returns the first item in the array,
 * otherwise returns the argument. Used for Preact compatibility.
 */
var unwrapArray = function unwrapArray(arg) {
    return Array.isArray(arg) ? arg[0] : arg;
};
/**
 * Takes a maybe-undefined function and arbitrary args and invokes the function
 * only if it is defined.
 */

var safeInvoke = function safeInvoke(fn) {
    if (typeof fn === "function") {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        return fn.apply(void 0, args);
    }
};
/**
 * Does a shallow equality check of two objects by comparing the reference
 * equality of each value.
 */

var shallowEqual = function shallowEqual(objA, objB) {
    var aKeys = Object.keys(objA);
    var bKeys = Object.keys(objB);

    if (bKeys.length !== aKeys.length) {
        return false;
    }

    for (var i = 0; i < bKeys.length; i++) {
        var key = aKeys[i];

        if (objA[key] !== objB[key]) {
            return false;
        }
    }

    return true;
};
/**
 * Sets a ref using either a ref callback or a ref object
 */

var setRef = function setRef(ref, node) {
    // if its a function call it
    if (typeof ref === "function") {
        return safeInvoke(ref, node);
    } // otherwise we should treat it as a ref object
    else if (ref != null) {
        ref.current = node;
    }
};

var initialStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    opacity: 0,
    pointerEvents: 'none'
};
var initialArrowStyle = {};
var InnerPopper =
    /*#__PURE__*/
    function(_React$Component) {
        inheritsLoose(InnerPopper, _React$Component);

        function InnerPopper() {
            var _this;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

            defineProperty(assertThisInitialized(_this), "state", {
                data: undefined,
                placement: undefined
            });

            defineProperty(assertThisInitialized(_this), "popperInstance", void 0);

            defineProperty(assertThisInitialized(_this), "popperNode", null);

            defineProperty(assertThisInitialized(_this), "arrowNode", null);

            defineProperty(assertThisInitialized(_this), "setPopperNode", function(popperNode) {
                if (!popperNode || _this.popperNode === popperNode) return;
                setRef(_this.props.innerRef, popperNode);
                _this.popperNode = popperNode;

                _this.updatePopperInstance();
            });

            defineProperty(assertThisInitialized(_this), "setArrowNode", function(arrowNode) {
                _this.arrowNode = arrowNode;
            });

            defineProperty(assertThisInitialized(_this), "updateStateModifier", {
                enabled: true,
                order: 900,
                fn: function fn(data) {
                    var placement = data.placement;

                    _this.setState({
                        data: data,
                        placement: placement
                    });

                    return data;
                }
            });

            defineProperty(assertThisInitialized(_this), "getOptions", function() {
                return {
                    placement: _this.props.placement,
                    eventsEnabled: _this.props.eventsEnabled,
                    positionFixed: _this.props.positionFixed,
                    modifiers: _extends_1({}, _this.props.modifiers, {
                        arrow: _extends_1({}, _this.props.modifiers && _this.props.modifiers.arrow, {
                            enabled: !!_this.arrowNode,
                            element: _this.arrowNode
                        }),
                        applyStyle: {
                            enabled: false
                        },
                        updateStateModifier: _this.updateStateModifier
                    })
                };
            });

            defineProperty(assertThisInitialized(_this), "getPopperStyle", function() {
                return !_this.popperNode || !_this.state.data ? initialStyle : _extends_1({
                    position: _this.state.data.offsets.popper.position
                }, _this.state.data.styles);
            });

            defineProperty(assertThisInitialized(_this), "getPopperPlacement", function() {
                return !_this.state.data ? undefined : _this.state.placement;
            });

            defineProperty(assertThisInitialized(_this), "getArrowStyle", function() {
                return !_this.arrowNode || !_this.state.data ? initialArrowStyle : _this.state.data.arrowStyles;
            });

            defineProperty(assertThisInitialized(_this), "getOutOfBoundariesState", function() {
                return _this.state.data ? _this.state.data.hide : undefined;
            });

            defineProperty(assertThisInitialized(_this), "destroyPopperInstance", function() {
                if (!_this.popperInstance) return;

                _this.popperInstance.destroy();

                _this.popperInstance = null;
            });

            defineProperty(assertThisInitialized(_this), "updatePopperInstance", function() {
                _this.destroyPopperInstance();

                var _assertThisInitialize = assertThisInitialized(_this),
                    popperNode = _assertThisInitialize.popperNode;

                var referenceElement = _this.props.referenceElement;
                if (!referenceElement || !popperNode) return;
                _this.popperInstance = new Popper(referenceElement, popperNode, _this.getOptions());
            });

            defineProperty(assertThisInitialized(_this), "scheduleUpdate", function() {
                if (_this.popperInstance) {
                    _this.popperInstance.scheduleUpdate();
                }
            });

            return _this;
        }

        var _proto = InnerPopper.prototype;

        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
            // If the Popper.js options have changed, update the instance (destroy + create)
            if (this.props.placement !== prevProps.placement || this.props.referenceElement !== prevProps.referenceElement || this.props.positionFixed !== prevProps.positionFixed || !deepEqual_1(this.props.modifiers, prevProps.modifiers, {
                    strict: true
                })) {
                // develop only check that modifiers isn't being updated needlessly
                if (process.env.NODE_ENV === "development") {
                    if (this.props.modifiers !== prevProps.modifiers && this.props.modifiers != null && prevProps.modifiers != null && shallowEqual(this.props.modifiers, prevProps.modifiers)) {
                        console.warn("'modifiers' prop reference updated even though all values appear the same.\nConsider memoizing the 'modifiers' object to avoid needless rendering.");
                    }
                }

                this.updatePopperInstance();
            } else if (this.props.eventsEnabled !== prevProps.eventsEnabled && this.popperInstance) {
                this.props.eventsEnabled ? this.popperInstance.enableEventListeners() : this.popperInstance.disableEventListeners();
            } // A placement difference in state means popper determined a new placement
            // apart from the props value. By the time the popper element is rendered with
            // the new position Popper has already measured it, if the place change triggers
            // a size change it will result in a misaligned popper. So we schedule an update to be sure.


            if (prevState.placement !== this.state.placement) {
                this.scheduleUpdate();
            }
        };

        _proto.componentWillUnmount = function componentWillUnmount() {
            setRef(this.props.innerRef, null);
            this.destroyPopperInstance();
        };

        _proto.render = function render() {
            return unwrapArray(this.props.children)({
                ref: this.setPopperNode,
                style: this.getPopperStyle(),
                placement: this.getPopperPlacement(),
                outOfBoundaries: this.getOutOfBoundariesState(),
                scheduleUpdate: this.scheduleUpdate,
                arrowProps: {
                    ref: this.setArrowNode,
                    style: this.getArrowStyle()
                }
            });
        };

        return InnerPopper;
    }(React.Component);

defineProperty(InnerPopper, "defaultProps", {
    placement: 'bottom',
    eventsEnabled: true,
    referenceElement: undefined,
    positionFixed: false
});

function Popper$1(_ref) {
    var referenceElement = _ref.referenceElement,
        props = objectWithoutPropertiesLoose(_ref, ["referenceElement"]);

    return React.createElement(ManagerReferenceNodeContext.Consumer, null, function(referenceNode) {
        return React.createElement(InnerPopper, _extends_1({
            referenceElement: referenceElement !== undefined ? referenceElement : referenceNode
        }, props));
    });
}

var InnerReference =
    /*#__PURE__*/
    function(_React$Component) {
        inheritsLoose(InnerReference, _React$Component);

        function InnerReference() {
            var _this;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

            defineProperty(assertThisInitialized(_this), "refHandler", function(node) {
                setRef(_this.props.innerRef, node);
                safeInvoke(_this.props.setReferenceNode, node);
            });

            return _this;
        }

        var _proto = InnerReference.prototype;

        _proto.componentWillUnmount = function componentWillUnmount() {
            setRef(this.props.innerRef, null);
        };

        _proto.render = function render() {
            warning_1(Boolean(this.props.setReferenceNode), '`Reference` should not be used outside of a `Manager` component.');
            return unwrapArray(this.props.children)({
                ref: this.refHandler
            });
        };

        return InnerReference;
    }(React.Component);

function Reference(props) {
    return React.createElement(ManagerReferenceNodeSetterContext.Consumer, null, function(setReferenceNode) {
        return React.createElement(InnerReference, _extends_1({
            setReferenceNode: setReferenceNode
        }, props));
    });
}

var PREFIX$j = "vds-popover";
/** Popover is a small overlay that appears contextually to provide messaging and additional content. */

var Popover = function(_a) {
    var children = _a.children,
        onClose = _a.onClose,
        trigger = _a.trigger,
        _b = _a.direction,
        direction = _b === void 0 ? "bottom" : _b,
        open = _a.open; // Close when clicked outside

    var popoverRef = React.useRef(null);
    useOnClickOutside(popoverRef, onClose); // Close when `esc` is pressed

    useOnEscKeyDown(onClose); // Setup classnames

    var className = classnames(PREFIX$j);
    var arrowClassName = classnames("vds-tail", "vds-tail--inverse");
    var popoverTrigger = /*#__PURE__*/ React__default.createElement(Reference, null, function(_a) {
        var ref = _a.ref;
        return /*#__PURE__*/ React__default.createElement("span", {
            "aria-describedby": PREFIX$j,
            "aria-expanded": open,
            "aria-haspopup": true,
            ref: ref
        }, trigger);
    });
    var popover = /*#__PURE__*/ React__default.createElement(Popper$1, {
        placement: useDirectionToPopperPlacement(direction)
    }, function(_a) {
        var ref = _a.ref,
            placement = _a.placement,
            style = _a.style,
            arrowProps = _a.arrowProps;
        return /*#__PURE__*/ React__default.createElement("span", {
            ref: popoverRef
        }, /*#__PURE__*/ React__default.createElement("span", {
            className: className,
            "data-placement": placement,
            id: PREFIX$j,
            ref: ref,
            role: "dialog",
            style: style
        }, /*#__PURE__*/ React__default.createElement("span", {
            className: arrowClassName,
            ref: arrowProps.ref,
            style: arrowProps.style
        }), children));
    });
    return /*#__PURE__*/ React__default.createElement(Manager, null, popoverTrigger, open && /*#__PURE__*/ reactDom.createPortal(popover, document.body));
};

var PREFIX$k = "vds-progress-bar";
/** A progress bar is used to visually represent the completion of a task or operation. */

var ProgressBar = function(_a) {
    var hiddenLabel = _a.hiddenLabel,
        _b = _a.labelAlign,
        labelAlign = _b === void 0 ? "inline" : _b,
        label = _a.label,
        _c = _a.size,
        size = _c === void 0 ? "sm" : _c,
        _d = _a.maxValue,
        maxValue = _d === void 0 ? 100 : _d,
        _e = _a.value,
        value = _e === void 0 ? 0 : _e,
        _f = _a.variant,
        variant = _f === void 0 ? "default" : _f;
    var className = classnames(PREFIX$k, labelAlign && PREFIX$k + "--" + labelAlign, size && PREFIX$k + "--" + size, variant && PREFIX$k + "--" + variant);
    var labelClassName = hiddenLabel ? "vds-visually-hidden" : PREFIX$k + "__label";
    var finalValue = maxValue ? Math.round(value / maxValue * 100) : value;
    var defaultLabel = finalValue + "%";
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className,
        role: "progressbar"
    }, /*#__PURE__*/ React__default.createElement("progress", {
        value: value,
        max: maxValue
    }), /*#__PURE__*/ React__default.createElement("span", {
        className: labelClassName
    }, label || defaultLabel));
};

var PREFIX$l = "vds-quote";
/**
 * @deprecated The Quote component is no longer supported or recommended for use.
 * Quote is for displaying quoted text, often used for testimonials.
 */

var Quote = function(_a) {
    var children = _a.children,
        _b = _a.align,
        align = _b === void 0 ? "center" : _b;
    var className = classnames(PREFIX$l, align !== "left" && "vds-text-align--" + align);
    return /*#__PURE__*/ React__default.createElement("blockquote", {
        className: className
    }, children);
};

var PREFIX$m = "vds-radio";
/** Radio is a single control for selecting a choice. Use `RadioGroup` for multiple options. */

var Radio = function(_a) {
    var id = _a.id,
        label = _a.label,
        autoFocus = _a.autoFocus,
        checked = _a.checked,
        defaultChecked = _a.defaultChecked,
        disabled = _a.disabled,
        hiddenLabel = _a.hiddenLabel,
        _b = _a.name,
        name = _b === void 0 ? PREFIX$m : _b,
        onChange = _a.onChange,
        required = _a.required,
        testID = _a.testID,
        value = _a.value;
    var className = classnames(PREFIX$m, hiddenLabel && PREFIX$m + "--hidden");
    var labelMarkup = hiddenLabel ? /*#__PURE__*/ React__default.createElement(VisuallyHidden, null, label) : label;
    var labelId = PREFIX$m + "--label--" + id;
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className
    }, /*#__PURE__*/ React__default.createElement("input", {
        "aria-labelledby": labelId,
        autoFocus: autoFocus,
        checked: checked,
        className: PREFIX$m + "__input",
        "data-testid": testID,
        defaultChecked: defaultChecked,
        disabled: disabled,
        id: id,
        name: name,
        onChange: onChange,
        required: required,
        type: "radio",
        value: value
    }), /*#__PURE__*/ React__default.createElement("label", {
        id: labelId,
        className: PREFIX$m + "__label",
        htmlFor: id
    }, labelMarkup));
};

var PREFIX$n = "vds-radio-group";
/** RadioGroup allows a single selection to be made from two or more list options. */

var RadioGroup = function(_a) {
    var children = _a.children,
        title = _a.title,
        hiddenTitle = _a.hiddenTitle,
        inline = _a.inline,
        _b = _a.name,
        name = _b === void 0 ? "vds-radio" : _b,
        onChange = _a.onChange;
    var className = classnames(PREFIX$n, inline && PREFIX$n + "--inline");
    var titleClassName = classnames(PREFIX$n + "__title", hiddenTitle && "vds-visually-hidden");
    var radioChildren = React.Children.map(children, function(child) {
        return /*#__PURE__*/ React.cloneElement(child, {
            name: name,
            onChange: onChange
        });
    });
    return /*#__PURE__*/ React__default.createElement("fieldset", {
        className: className
    }, /*#__PURE__*/ React__default.createElement("legend", {
        className: titleClassName
    }, title), radioChildren);
};

function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }

    return target;
}

function _extends$2() {
    _extends$2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    return _extends$2.apply(this, arguments);
}

function _assertThisInitialized$2(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
}

function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };

    return _setPrototypeOf$1(o, p);
}

function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
}

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for,
    c = b ? Symbol.for("react.element") : 60103,
    d = b ? Symbol.for("react.portal") : 60106,
    e = b ? Symbol.for("react.fragment") : 60107,
    f = b ? Symbol.for("react.strict_mode") : 60108,
    g = b ? Symbol.for("react.profiler") : 60114,
    h = b ? Symbol.for("react.provider") : 60109,
    k = b ? Symbol.for("react.context") : 60110,
    l = b ? Symbol.for("react.async_mode") : 60111,
    m = b ? Symbol.for("react.concurrent_mode") : 60111,
    n = b ? Symbol.for("react.forward_ref") : 60112,
    p = b ? Symbol.for("react.suspense") : 60113,
    q = b ?
    Symbol.for("react.suspense_list") : 60120,
    r = b ? Symbol.for("react.memo") : 60115,
    t = b ? Symbol.for("react.lazy") : 60116,
    v = b ? Symbol.for("react.block") : 60121,
    w = b ? Symbol.for("react.fundamental") : 60117,
    x = b ? Symbol.for("react.responder") : 60118,
    y = b ? Symbol.for("react.scope") : 60119;

function z(a) {
    if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
            case c:
                switch (a = a.type, a) {
                    case l:
                    case m:
                    case e:
                    case g:
                    case f:
                    case p:
                        return a;
                    default:
                        switch (a = a && a.$$typeof, a) {
                            case k:
                            case n:
                            case t:
                            case r:
                            case h:
                                return a;
                            default:
                                return u
                        }
                }
            case d:
                return u
        }
    }
}

function A(a) {
    return z(a) === m
}
var AsyncMode = l;
var ConcurrentMode = m;
var ContextConsumer = k;
var ContextProvider = h;
var Element$1 = c;
var ForwardRef = n;
var Fragment = e;
var Lazy = t;
var Memo = r;
var Portal = d;
var Profiler = g;
var StrictMode = f;
var Suspense = p;
var isAsyncMode = function(a) {
    return A(a) || z(a) === l
};
var isConcurrentMode = A;
var isContextConsumer = function(a) {
    return z(a) === k
};
var isContextProvider = function(a) {
    return z(a) === h
};
var isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c
};
var isForwardRef = function(a) {
    return z(a) === n
};
var isFragment = function(a) {
    return z(a) === e
};
var isLazy = function(a) {
    return z(a) === t
};
var isMemo = function(a) {
    return z(a) === r
};
var isPortal = function(a) {
    return z(a) === d
};
var isProfiler = function(a) {
    return z(a) === g
};
var isStrictMode = function(a) {
    return z(a) === f
};
var isSuspense = function(a) {
    return z(a) === p
};
var isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v)
};
var typeOf = z;

var reactIs_production_min = {
    AsyncMode: AsyncMode,
    ConcurrentMode: ConcurrentMode,
    ContextConsumer: ContextConsumer,
    ContextProvider: ContextProvider,
    Element: Element$1,
    ForwardRef: ForwardRef,
    Fragment: Fragment,
    Lazy: Lazy,
    Memo: Memo,
    Portal: Portal,
    Profiler: Profiler,
    StrictMode: StrictMode,
    Suspense: Suspense,
    isAsyncMode: isAsyncMode,
    isConcurrentMode: isConcurrentMode,
    isContextConsumer: isContextConsumer,
    isContextProvider: isContextProvider,
    isElement: isElement,
    isForwardRef: isForwardRef,
    isFragment: isFragment,
    isLazy: isLazy,
    isMemo: isMemo,
    isPortal: isPortal,
    isProfiler: isProfiler,
    isStrictMode: isStrictMode,
    isSuspense: isSuspense,
    isValidElementType: isValidElementType,
    typeOf: typeOf
};

var reactIs_development = createCommonjsModule(function(module, exports) {



    if (process.env.NODE_ENV !== "production") {
        (function() {

            // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
            // nor polyfill, then a plain number is used for performance.
            var hasSymbol = typeof Symbol === 'function' && Symbol.for;
            var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
            var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
            var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
            var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
            var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
            var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
            var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
            // (unstable) APIs that have been removed. Can we remove the symbols?

            var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
            var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
            var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
            var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
            var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
            var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
            var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
            var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
            var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
            var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
            var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

            function isValidElementType(type) {
                return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
                    type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
            }

            function typeOf(object) {
                if (typeof object === 'object' && object !== null) {
                    var $$typeof = object.$$typeof;

                    switch ($$typeof) {
                        case REACT_ELEMENT_TYPE:
                            var type = object.type;

                            switch (type) {
                                case REACT_ASYNC_MODE_TYPE:
                                case REACT_CONCURRENT_MODE_TYPE:
                                case REACT_FRAGMENT_TYPE:
                                case REACT_PROFILER_TYPE:
                                case REACT_STRICT_MODE_TYPE:
                                case REACT_SUSPENSE_TYPE:
                                    return type;

                                default:
                                    var $$typeofType = type && type.$$typeof;

                                    switch ($$typeofType) {
                                        case REACT_CONTEXT_TYPE:
                                        case REACT_FORWARD_REF_TYPE:
                                        case REACT_LAZY_TYPE:
                                        case REACT_MEMO_TYPE:
                                        case REACT_PROVIDER_TYPE:
                                            return $$typeofType;

                                        default:
                                            return $$typeof;
                                    }

                            }

                        case REACT_PORTAL_TYPE:
                            return $$typeof;
                    }
                }

                return undefined;
            } // AsyncMode is deprecated along with isAsyncMode

            var AsyncMode = REACT_ASYNC_MODE_TYPE;
            var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
            var ContextConsumer = REACT_CONTEXT_TYPE;
            var ContextProvider = REACT_PROVIDER_TYPE;
            var Element = REACT_ELEMENT_TYPE;
            var ForwardRef = REACT_FORWARD_REF_TYPE;
            var Fragment = REACT_FRAGMENT_TYPE;
            var Lazy = REACT_LAZY_TYPE;
            var Memo = REACT_MEMO_TYPE;
            var Portal = REACT_PORTAL_TYPE;
            var Profiler = REACT_PROFILER_TYPE;
            var StrictMode = REACT_STRICT_MODE_TYPE;
            var Suspense = REACT_SUSPENSE_TYPE;
            var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

            function isAsyncMode(object) {
                {
                    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                        hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

                        console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
                    }
                }

                return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
            }

            function isConcurrentMode(object) {
                return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
            }

            function isContextConsumer(object) {
                return typeOf(object) === REACT_CONTEXT_TYPE;
            }

            function isContextProvider(object) {
                return typeOf(object) === REACT_PROVIDER_TYPE;
            }

            function isElement(object) {
                return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }

            function isForwardRef(object) {
                return typeOf(object) === REACT_FORWARD_REF_TYPE;
            }

            function isFragment(object) {
                return typeOf(object) === REACT_FRAGMENT_TYPE;
            }

            function isLazy(object) {
                return typeOf(object) === REACT_LAZY_TYPE;
            }

            function isMemo(object) {
                return typeOf(object) === REACT_MEMO_TYPE;
            }

            function isPortal(object) {
                return typeOf(object) === REACT_PORTAL_TYPE;
            }

            function isProfiler(object) {
                return typeOf(object) === REACT_PROFILER_TYPE;
            }

            function isStrictMode(object) {
                return typeOf(object) === REACT_STRICT_MODE_TYPE;
            }

            function isSuspense(object) {
                return typeOf(object) === REACT_SUSPENSE_TYPE;
            }

            exports.AsyncMode = AsyncMode;
            exports.ConcurrentMode = ConcurrentMode;
            exports.ContextConsumer = ContextConsumer;
            exports.ContextProvider = ContextProvider;
            exports.Element = Element;
            exports.ForwardRef = ForwardRef;
            exports.Fragment = Fragment;
            exports.Lazy = Lazy;
            exports.Memo = Memo;
            exports.Portal = Portal;
            exports.Profiler = Profiler;
            exports.StrictMode = StrictMode;
            exports.Suspense = Suspense;
            exports.isAsyncMode = isAsyncMode;
            exports.isConcurrentMode = isConcurrentMode;
            exports.isContextConsumer = isContextConsumer;
            exports.isContextProvider = isContextProvider;
            exports.isElement = isElement;
            exports.isForwardRef = isForwardRef;
            exports.isFragment = isFragment;
            exports.isLazy = isLazy;
            exports.isMemo = isMemo;
            exports.isPortal = isPortal;
            exports.isProfiler = isProfiler;
            exports.isStrictMode = isStrictMode;
            exports.isSuspense = isSuspense;
            exports.isValidElementType = isValidElementType;
            exports.typeOf = typeOf;
        })();
    }
});

var reactIs = createCommonjsModule(function(module) {

    if (process.env.NODE_ENV === 'production') {
        module.exports = reactIs_production_min;
    } else {
        module.exports = reactIs_development;
    }
});

function t$1(t) {
    return null != t && "object" == typeof t && 1 === t.nodeType
}

function e$1(t, e) {
    return (!e || "hidden" !== t) && "visible" !== t && "clip" !== t
}

function n$1(t, n) {
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
        var r = getComputedStyle(t, null);
        return e$1(r.overflowY, n) || e$1(r.overflowX, n) || function(t) {
            var e = function(t) {
                if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;
                try {
                    return t.ownerDocument.defaultView.frameElement
                } catch (t) {
                    return null
                }
            }(t);
            return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth)
        }(t)
    }
    return !1
}

function r$1(t, e, n, r, i, o, l, d) {
    return o < t && l > e || o > t && l < e ? 0 : o <= t && d <= n || l >= e && d >= n ? o - t - r : l > e && d < n || o < t && d > n ? l - e + i : 0
}

function computeScrollIntoView(e, i) {
    var o = window,
        l = i.scrollMode,
        d = i.block,
        u = i.inline,
        h = i.boundary,
        a = i.skipOverflowHiddenElements,
        c = "function" == typeof h ? h : function(t) {
            return t !== h
        };
    if (!t$1(e)) throw new TypeError("Invalid target");
    for (var f = document.scrollingElement || document.documentElement, s = [], p = e; t$1(p) && c(p);) {
        if ((p = p.parentNode) === f) {
            s.push(p);
            break
        }
        p === document.body && n$1(p) && !n$1(document.documentElement) || n$1(p, a) && s.push(p);
    }
    for (var g = o.visualViewport ? o.visualViewport.width : innerWidth, m = o.visualViewport ? o.visualViewport.height : innerHeight, w = window.scrollX || pageXOffset, v = window.scrollY || pageYOffset, W = e.getBoundingClientRect(), b = W.height, H = W.width, y = W.top, M = W.right, E = W.bottom, V = W.left, x = "start" === d || "nearest" === d ? y : "end" === d ? E : y + b / 2, I = "center" === u ? V + H / 2 : "end" === u ? M : V, C = [], T = 0; T < s.length; T++) {
        var k = s[T],
            B = k.getBoundingClientRect(),
            D = B.height,
            O = B.width,
            R = B.top,
            X = B.right,
            Y = B.bottom,
            L = B.left;
        if ("if-needed" === l && y >= 0 && V >= 0 && E <= m && M <= g && y >= R && E <= Y && V >= L && M <= X) return C;
        var S = getComputedStyle(k),
            j = parseInt(S.borderLeftWidth, 10),
            N = parseInt(S.borderTopWidth, 10),
            q = parseInt(S.borderRightWidth, 10),
            z = parseInt(S.borderBottomWidth, 10),
            A = 0,
            F = 0,
            G = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - j - q : 0,
            J = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - N - z : 0;
        if (f === k) A = "start" === d ? x : "end" === d ? x - m : "nearest" === d ? r$1(v, v + m, m, N, z, v + x, v + x + b, b) : x - m / 2, F = "start" === u ? I : "center" === u ? I - g / 2 : "end" === u ? I - g : r$1(w, w + g, g, j, q, w + I, w + I + H, H), A = Math.max(0, A + v), F = Math.max(0, F + w);
        else {
            A = "start" === d ? x - R - N : "end" === d ? x - Y + z + J : "nearest" === d ? r$1(R, Y, D, N, z + J, x, x + b, b) : x - (R + D / 2) + J / 2, F = "start" === u ? I - L - j : "center" === u ? I - (L + O / 2) + G / 2 : "end" === u ? I - X + q + G : r$1(L, X, O, j, q + G, I, I + H, H);
            var K = k.scrollLeft,
                P = k.scrollTop;
            x += P - (A = Math.max(0, Math.min(P + A, k.scrollHeight - D + J))), I += K - (F = Math.max(0, Math.min(K + F, k.scrollWidth - O + G)));
        }
        C.push({
            el: k,
            top: A,
            left: F
        });
    }
    return C
}

var idCounter = 0;
/**
 * Accepts a parameter and returns it if it's a function
 * or a noop function if it's not. This allows us to
 * accept a callback, but not worry about it if it's not
 * passed.
 * @param {Function} cb the callback
 * @return {Function} a function
 */

function cbToCb(cb) {
    return typeof cb === 'function' ? cb : noop;
}

function noop() {}
/**
 * Scroll node into view if necessary
 * @param {HTMLElement} node the element that should scroll into view
 * @param {HTMLElement} menuNode the menu element of the component
 */


function scrollIntoView(node, menuNode) {
    if (!node) {
        return;
    }

    var actions = computeScrollIntoView(node, {
        boundary: menuNode,
        block: 'nearest',
        scrollMode: 'if-needed'
    });
    actions.forEach(function(_ref) {
        var el = _ref.el,
            top = _ref.top,
            left = _ref.left;
        el.scrollTop = top;
        el.scrollLeft = left;
    });
}
/**
 * @param {HTMLElement} parent the parent node
 * @param {HTMLElement} child the child node
 * @return {Boolean} whether the parent is the child or the child is in the parent
 */


function isOrContainsNode(parent, child) {
    return parent === child || parent.contains && parent.contains(child);
}
/**
 * Simple debounce implementation. Will call the given
 * function once after the time given has passed since
 * it was last called.
 * @param {Function} fn the function to call after the time
 * @param {Number} time the time to wait
 * @return {Function} the debounced function
 */


function debounce$1(fn, time) {
    var timeoutId;

    function cancel() {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
    }

    function wrapper() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        cancel();
        timeoutId = setTimeout(function() {
            timeoutId = null;
            fn.apply(void 0, args);
        }, time);
    }

    wrapper.cancel = cancel;
    return wrapper;
}
/**
 * This is intended to be used to compose event handlers.
 * They are executed in order until one of them sets
 * `event.preventDownshiftDefault = true`.
 * @param {...Function} fns the event handler functions
 * @return {Function} the event handler to add to an element
 */


function callAllEventHandlers() {
    for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        fns[_key2] = arguments[_key2];
    }

    return function(event) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
        }

        return fns.some(function(fn) {
            if (fn) {
                fn.apply(void 0, [event].concat(args));
            }

            return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;
        });
    };
}

function handleRefs() {
    for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        refs[_key4] = arguments[_key4];
    }

    return function(node) {
        refs.forEach(function(ref) {
            if (typeof ref === 'function') {
                ref(node);
            } else if (ref) {
                ref.current = node;
            }
        });
    };
}
/**
 * This generates a unique ID for an instance of Downshift
 * @return {String} the unique ID
 */


function generateId() {
    return String(idCounter++);
}
/**
 * Default implementation for status message. Only added when menu is open.
 * Will specift if there are results in the list, and if so, how many,
 * and what keys are relevant.
 *
 * @param {Object} param the downshift state and other relevant properties
 * @return {String} the a11y status message
 */


function getA11yStatusMessage(_ref2) {
    var isOpen = _ref2.isOpen,
        resultCount = _ref2.resultCount,
        previousResultCount = _ref2.previousResultCount;

    if (!isOpen) {
        return '';
    }

    if (!resultCount) {
        return 'No results are available.';
    }

    if (resultCount !== previousResultCount) {
        return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter key to select.";
    }

    return '';
}
/**
 * Takes an argument and if it's an array, returns the first item in the array
 * otherwise returns the argument
 * @param {*} arg the maybe-array
 * @param {*} defaultValue the value if arg is falsey not defined
 * @return {*} the arg or it's first item
 */


function unwrapArray$1(arg, defaultValue) {
    arg = Array.isArray(arg) ?
        /* istanbul ignore next (preact) */
        arg[0] : arg;

    if (!arg && defaultValue) {
        return defaultValue;
    } else {
        return arg;
    }
}
/**
 * @param {Object} element (P)react element
 * @return {Boolean} whether it's a DOM element
 */


function isDOMElement(element) {
    // then we assume this is react
    return typeof element.type === 'string';
}
/**
 * @param {Object} element (P)react element
 * @return {Object} the props
 */


function getElementProps(element) {
    return element.props;
}
/**
 * Throws a helpful error message for required properties. Useful
 * to be used as a default in destructuring or object params.
 * @param {String} fnName the function name
 * @param {String} propName the prop name
 */


function requiredProp(fnName, propName) {
    // eslint-disable-next-line no-console
    console.error("The property \"" + propName + "\" is required in \"" + fnName + "\"");
}

var stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];
/**
 * @param {Object} state the state object
 * @return {Object} state that is relevant to downshift
 */

function pickState(state) {
    if (state === void 0) {
        state = {};
    }

    var result = {};
    stateKeys.forEach(function(k) {
        if (state.hasOwnProperty(k)) {
            result[k] = state[k];
        }
    });
    return result;
}
/**
 * This will perform a shallow merge of the given state object
 * with the state coming from props
 * (for the controlled component scenario)
 * This is used in state updater functions so they're referencing
 * the right state regardless of where it comes from.
 *
 * @param {Object} state The state of the component/hook.
 * @param {Object} props The props that may contain controlled values.
 * @returns {Object} The merged controlled state.
 */


function getState(state, props) {
    return Object.keys(state).reduce(function(prevState, key) {
        prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
        return prevState;
    }, {});
}
/**
 * This determines whether a prop is a "controlled prop" meaning it is
 * state which is controlled by the outside of this component rather
 * than within this component.
 *
 * @param {Object} props The props that may contain controlled values.
 * @param {String} key the key to check
 * @return {Boolean} whether it is a controlled controlled prop
 */


function isControlledProp(props, key) {
    return props[key] !== undefined;
}
/**
 * Normalizes the 'key' property of a KeyboardEvent in IE/Edge
 * @param {Object} event a keyboardEvent object
 * @return {String} keyboard key
 */


function normalizeArrowKey(event) {
    var key = event.key,
        keyCode = event.keyCode;
    /* istanbul ignore next (ie) */

    if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {
        return "Arrow" + key;
    }

    return key;
}
/**
 * Simple check if the value passed is object literal
 * @param {*} obj any things
 * @return {Boolean} whether it's object literal
 */


function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}
/**
 * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,
 * it will wrap to either 0 or itemCount - 1.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index after the move.
 */


function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    if (circular === void 0) {
        circular = true;
    }

    if (itemCount === 0) {
        return -1;
    }

    var itemsLastIndex = itemCount - 1;

    if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {
        baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
    }

    var newIndex = baseIndex + moveAmount;

    if (newIndex < 0) {
        newIndex = circular ? itemsLastIndex : 0;
    } else if (newIndex > itemsLastIndex) {
        newIndex = circular ? 0 : itemsLastIndex;
    }

    var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
    return nonDisabledNewIndex === -1 ? baseIndex : nonDisabledNewIndex;
}
/**
 * Returns the next index in the list of an item that is not disabled.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.
 */


function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    var currentElementNode = getItemNodeFromIndex(baseIndex);

    if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {
        return baseIndex;
    }

    if (moveAmount > 0) {
        for (var index = baseIndex + 1; index < itemCount; index++) {
            if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {
                return index;
            }
        }
    } else {
        for (var _index = baseIndex - 1; _index >= 0; _index--) {
            if (!getItemNodeFromIndex(_index).hasAttribute('disabled')) {
                return _index;
            }
        }
    }

    if (circular) {
        return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
    }

    return -1;
}
/**
 * Checks if event target is within the downshift elements.
 *
 * @param {EventTarget} target Target to check.
 * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).
 * @param {Document} document The document.
 * @param {boolean} checkActiveElement Whether to also check activeElement.
 *
 * @returns {boolean} Whether or not the target is within downshift elements.
 */


function targetWithinDownshift(target, downshiftElements, document, checkActiveElement) {
    if (checkActiveElement === void 0) {
        checkActiveElement = true;
    }

    return downshiftElements.some(function(contextNode) {
        return contextNode && (isOrContainsNode(contextNode, target) || checkActiveElement && isOrContainsNode(contextNode, document.activeElement));
    });
}

function validateControlledUnchanged(state, prevProps, nextProps) {
    if (process.env.NODE_ENV === 'production') {
        return;
    }

    var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
    Object.keys(state).forEach(function(propKey) {
        if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {
            // eslint-disable-next-line no-console
            console.error("downshift: A component has changed the controlled prop \"" + propKey + "\" to be uncontrolled. " + warningDescription);
        } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {
            // eslint-disable-next-line no-console
            console.error("downshift: A component has changed the uncontrolled prop \"" + propKey + "\" to be controlled. " + warningDescription);
        }
    });
}

var cleanupStatus = debounce$1(function() {
    getStatusDiv().textContent = '';
}, 500);
/**
 * @param {String} status the status message
 * @param {Object} documentProp document passed by the user.
 */

function setStatus(status, documentProp) {
    var div = getStatusDiv(documentProp);

    if (!status) {
        return;
    }

    div.textContent = status;
    cleanupStatus();
}
/**
 * Get the status node or create it if it does not already exist.
 * @param {Object} documentProp document passed by the user.
 * @return {HTMLElement} the status node.
 */


function getStatusDiv(documentProp) {
    if (documentProp === void 0) {
        documentProp = document;
    }

    var statusDiv = documentProp.getElementById('a11y-status-message');

    if (statusDiv) {
        return statusDiv;
    }

    statusDiv = documentProp.createElement('div');
    statusDiv.setAttribute('id', 'a11y-status-message');
    statusDiv.setAttribute('role', 'status');
    statusDiv.setAttribute('aria-live', 'polite');
    statusDiv.setAttribute('aria-relevant', 'additions text');
    Object.assign(statusDiv.style, {
        border: '0',
        clip: 'rect(0 0 0 0)',
        height: '1px',
        margin: '-1px',
        overflow: 'hidden',
        padding: '0',
        position: 'absolute',
        width: '1px'
    });
    documentProp.body.appendChild(statusDiv);
    return statusDiv;
}

var unknown = process.env.NODE_ENV !== "production" ? '__autocomplete_unknown__' : 0;
var mouseUp = process.env.NODE_ENV !== "production" ? '__autocomplete_mouseup__' : 1;
var itemMouseEnter = process.env.NODE_ENV !== "production" ? '__autocomplete_item_mouseenter__' : 2;
var keyDownArrowUp = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_arrow_up__' : 3;
var keyDownArrowDown = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_arrow_down__' : 4;
var keyDownEscape = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_escape__' : 5;
var keyDownEnter = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_enter__' : 6;
var keyDownHome = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_home__' : 7;
var keyDownEnd = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_end__' : 8;
var clickItem = process.env.NODE_ENV !== "production" ? '__autocomplete_click_item__' : 9;
var blurInput = process.env.NODE_ENV !== "production" ? '__autocomplete_blur_input__' : 10;
var changeInput = process.env.NODE_ENV !== "production" ? '__autocomplete_change_input__' : 11;
var keyDownSpaceButton = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_space_button__' : 12;
var clickButton = process.env.NODE_ENV !== "production" ? '__autocomplete_click_button__' : 13;
var blurButton = process.env.NODE_ENV !== "production" ? '__autocomplete_blur_button__' : 14;
var controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== "production" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;
var touchEnd = process.env.NODE_ENV !== "production" ? '__autocomplete_touchend__' : 16;

var stateChangeTypes = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    unknown: unknown,
    mouseUp: mouseUp,
    itemMouseEnter: itemMouseEnter,
    keyDownArrowUp: keyDownArrowUp,
    keyDownArrowDown: keyDownArrowDown,
    keyDownEscape: keyDownEscape,
    keyDownEnter: keyDownEnter,
    keyDownHome: keyDownHome,
    keyDownEnd: keyDownEnd,
    clickItem: clickItem,
    blurInput: blurInput,
    changeInput: changeInput,
    keyDownSpaceButton: keyDownSpaceButton,
    clickButton: clickButton,
    blurButton: blurButton,
    controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,
    touchEnd: touchEnd
});

var Downshift =
    /*#__PURE__*/
    function() {
        var Downshift =
            /*#__PURE__*/
            function(_Component) {
                _inheritsLoose$1(Downshift, _Component);

                function Downshift(_props) {
                    var _this = _Component.call(this, _props) || this;

                    _this.id = _this.props.id || "downshift-" + generateId();
                    _this.menuId = _this.props.menuId || _this.id + "-menu";
                    _this.labelId = _this.props.labelId || _this.id + "-label";
                    _this.inputId = _this.props.inputId || _this.id + "-input";

                    _this.getItemId = _this.props.getItemId || function(index) {
                        return _this.id + "-item-" + index;
                    };

                    _this.input = null;
                    _this.items = [];
                    _this.itemCount = null;
                    _this.previousResultCount = 0;
                    _this.timeoutIds = [];

                    _this.internalSetTimeout = function(fn, time) {
                        var id = setTimeout(function() {
                            _this.timeoutIds = _this.timeoutIds.filter(function(i) {
                                return i !== id;
                            });
                            fn();
                        }, time);

                        _this.timeoutIds.push(id);
                    };

                    _this.setItemCount = function(count) {
                        _this.itemCount = count;
                    };

                    _this.unsetItemCount = function() {
                        _this.itemCount = null;
                    };

                    _this.setHighlightedIndex = function(highlightedIndex, otherStateToSet) {
                        if (highlightedIndex === void 0) {
                            highlightedIndex = _this.props.defaultHighlightedIndex;
                        }

                        if (otherStateToSet === void 0) {
                            otherStateToSet = {};
                        }

                        otherStateToSet = pickState(otherStateToSet);

                        _this.internalSetState(_extends$2({
                            highlightedIndex: highlightedIndex
                        }, otherStateToSet));
                    };

                    _this.clearSelection = function(cb) {
                        _this.internalSetState({
                            selectedItem: null,
                            inputValue: '',
                            highlightedIndex: _this.props.defaultHighlightedIndex,
                            isOpen: _this.props.defaultIsOpen
                        }, cb);
                    };

                    _this.selectItem = function(item, otherStateToSet, cb) {
                        otherStateToSet = pickState(otherStateToSet);

                        _this.internalSetState(_extends$2({
                            isOpen: _this.props.defaultIsOpen,
                            highlightedIndex: _this.props.defaultHighlightedIndex,
                            selectedItem: item,
                            inputValue: _this.props.itemToString(item)
                        }, otherStateToSet), cb);
                    };

                    _this.selectItemAtIndex = function(itemIndex, otherStateToSet, cb) {
                        var item = _this.items[itemIndex];

                        if (item == null) {
                            return;
                        }

                        _this.selectItem(item, otherStateToSet, cb);
                    };

                    _this.selectHighlightedItem = function(otherStateToSet, cb) {
                        return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
                    };

                    _this.internalSetState = function(stateToSet, cb) {
                        var isItemSelected, onChangeArg;
                        var onStateChangeArg = {};
                        var isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call
                        // so someone controlling the `inputValue` state gets notified of
                        // the input change as soon as possible. This avoids issues with
                        // preserving the cursor position.
                        // See https://github.com/downshift-js/downshift/issues/217 for more info.

                        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {
                            _this.props.onInputValueChange(stateToSet.inputValue, _extends$2(_extends$2({}, _this.getStateAndHelpers()), stateToSet));
                        }

                        return _this.setState(function(state) {
                            state = _this.getState(state);
                            var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.

                            newStateToSet = _this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from
                            // what was selected before
                            // used to determine if onSelect and onChange callbacks should be called

                            isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState

                            var nextState = {}; // this is just used to tell whether the state changed

                            var nextFullState = {}; // we need to call on change if the outside world is controlling any of our state
                            // and we're trying to update that state. OR if the selection has changed and we're
                            // trying to update the selection

                            if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
                                onChangeArg = newStateToSet.selectedItem;
                            }

                            newStateToSet.type = newStateToSet.type || unknown;
                            Object.keys(newStateToSet).forEach(function(key) {
                                // onStateChangeArg should only have the state that is
                                // actually changing
                                if (state[key] !== newStateToSet[key]) {
                                    onStateChangeArg[key] = newStateToSet[key];
                                } // the type is useful for the onStateChangeArg
                                // but we don't actually want to set it in internal state.
                                // this is an undocumented feature for now... Not all internalSetState
                                // calls support it and I'm not certain we want them to yet.
                                // But it enables users controlling the isOpen state to know when
                                // the isOpen state changes due to mouseup events which is quite handy.


                                if (key === 'type') {
                                    return;
                                }

                                nextFullState[key] = newStateToSet[key]; // if it's coming from props, then we don't care to set it internally

                                if (!isControlledProp(_this.props, key)) {
                                    nextState[key] = newStateToSet[key];
                                }
                            }); // if stateToSet is a function, then we weren't able to call onInputValueChange
                            // earlier, so we'll call it now that we know what the inputValue state will be.

                            if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {
                                _this.props.onInputValueChange(newStateToSet.inputValue, _extends$2(_extends$2({}, _this.getStateAndHelpers()), newStateToSet));
                            }

                            return nextState;
                        }, function() {
                            // call the provided callback if it's a function
                            cbToCb(cb)(); // only call the onStateChange and onChange callbacks if
                            // we have relevant information to pass them.

                            var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;

                            if (hasMoreStateThanType) {
                                _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
                            }

                            if (isItemSelected) {
                                _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
                            }

                            if (onChangeArg !== undefined) {
                                _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
                            } // this is currently undocumented and therefore subject to change
                            // We'll try to not break it, but just be warned.


                            _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
                        });
                    };

                    _this.rootRef = function(node) {
                        return _this._rootNode = node;
                    };

                    _this.getRootProps = function(_temp, _temp2) {
                        var _extends2;

                        var _ref = _temp === void 0 ? {} : _temp,
                            _ref$refKey = _ref.refKey,
                            refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
                            ref = _ref.ref,
                            rest = _objectWithoutPropertiesLoose$1(_ref, ["refKey", "ref"]);

                        var _ref2 = _temp2 === void 0 ? {} : _temp2,
                            _ref2$suppressRefErro = _ref2.suppressRefError,
                            suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;

                        // this is used in the render to know whether the user has called getRootProps.
                        // It uses that to know whether to apply the props automatically
                        _this.getRootProps.called = true;
                        _this.getRootProps.refKey = refKey;
                        _this.getRootProps.suppressRefError = suppressRefError;

                        var _this$getState = _this.getState(),
                            isOpen = _this$getState.isOpen;

                        return _extends$2((_extends2 = {}, _extends2[refKey] = handleRefs(ref, _this.rootRef), _extends2.role = 'combobox', _extends2['aria-expanded'] = isOpen, _extends2['aria-haspopup'] = 'listbox', _extends2['aria-owns'] = isOpen ? _this.menuId : null, _extends2['aria-labelledby'] = _this.labelId, _extends2), rest);
                    };

                    _this.keyDownHandlers = {
                        ArrowDown: function ArrowDown(event) {
                            var _this2 = this;

                            event.preventDefault();

                            if (this.getState().isOpen) {
                                var amount = event.shiftKey ? 5 : 1;
                                this.moveHighlightedIndex(amount, {
                                    type: keyDownArrowDown
                                });
                            } else {
                                this.internalSetState({
                                    isOpen: true,
                                    type: keyDownArrowDown
                                }, function() {
                                    var itemCount = _this2.getItemCount();

                                    if (itemCount > 0) {
                                        var _this2$getState = _this2.getState(),
                                            highlightedIndex = _this2$getState.highlightedIndex;

                                        var nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, function(index) {
                                            return _this2.getItemNodeFromIndex(index);
                                        });

                                        _this2.setHighlightedIndex(nextHighlightedIndex, {
                                            type: keyDownArrowDown
                                        });
                                    }
                                });
                            }
                        },
                        ArrowUp: function ArrowUp(event) {
                            var _this3 = this;

                            event.preventDefault();

                            if (this.getState().isOpen) {
                                var amount = event.shiftKey ? -5 : -1;
                                this.moveHighlightedIndex(amount, {
                                    type: keyDownArrowUp
                                });
                            } else {
                                this.internalSetState({
                                    isOpen: true,
                                    type: keyDownArrowUp
                                }, function() {
                                    var itemCount = _this3.getItemCount();

                                    if (itemCount > 0) {
                                        var _this3$getState = _this3.getState(),
                                            highlightedIndex = _this3$getState.highlightedIndex;

                                        var nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, function(index) {
                                            return _this3.getItemNodeFromIndex(index);
                                        });

                                        _this3.setHighlightedIndex(nextHighlightedIndex, {
                                            type: keyDownArrowUp
                                        });
                                    }
                                });
                            }
                        },
                        Enter: function Enter(event) {
                            if (event.which === 229) {
                                return;
                            }

                            var _this$getState2 = this.getState(),
                                isOpen = _this$getState2.isOpen,
                                highlightedIndex = _this$getState2.highlightedIndex;

                            if (isOpen && highlightedIndex != null) {
                                event.preventDefault();
                                var item = this.items[highlightedIndex];
                                var itemNode = this.getItemNodeFromIndex(highlightedIndex);

                                if (item == null || itemNode && itemNode.hasAttribute('disabled')) {
                                    return;
                                }

                                this.selectHighlightedItem({
                                    type: keyDownEnter
                                });
                            }
                        },
                        Escape: function Escape(event) {
                            event.preventDefault();
                            this.reset({
                                type: keyDownEscape,
                                selectedItem: null,
                                inputValue: ''
                            });
                        }
                    };
                    _this.buttonKeyDownHandlers = _extends$2(_extends$2({}, _this.keyDownHandlers), {}, {
                        ' ': function _(event) {
                            event.preventDefault();
                            this.toggleMenu({
                                type: keyDownSpaceButton
                            });
                        }
                    });
                    _this.inputKeyDownHandlers = _extends$2(_extends$2({}, _this.keyDownHandlers), {}, {
                        Home: function Home(event) {
                            var _this4 = this;

                            event.preventDefault();
                            var itemCount = this.getItemCount();

                            var _this$getState3 = this.getState(),
                                isOpen = _this$getState3.isOpen;

                            if (itemCount <= 0 || !isOpen) {
                                return;
                            } // get next non-disabled starting downwards from 0 if that's disabled.


                            var newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, function(index) {
                                return _this4.getItemNodeFromIndex(index);
                            }, false);
                            this.setHighlightedIndex(newHighlightedIndex, {
                                type: keyDownHome
                            });
                        },
                        End: function End(event) {
                            var _this5 = this;

                            event.preventDefault();
                            var itemCount = this.getItemCount();

                            var _this$getState4 = this.getState(),
                                isOpen = _this$getState4.isOpen;

                            if (itemCount <= 0 || !isOpen) {
                                return;
                            } // get next non-disabled starting upwards from last index if that's disabled.


                            var newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, function(index) {
                                return _this5.getItemNodeFromIndex(index);
                            }, false);
                            this.setHighlightedIndex(newHighlightedIndex, {
                                type: keyDownEnd
                            });
                        }
                    });

                    _this.getToggleButtonProps = function(_temp3) {
                        var _ref3 = _temp3 === void 0 ? {} : _temp3,
                            onClick = _ref3.onClick,
                            onPress = _ref3.onPress,
                            onKeyDown = _ref3.onKeyDown,
                            onKeyUp = _ref3.onKeyUp,
                            onBlur = _ref3.onBlur,
                            rest = _objectWithoutPropertiesLoose$1(_ref3, ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"]);

                        var _this$getState5 = _this.getState(),
                            isOpen = _this$getState5.isOpen;

                        var enabledEventHandlers = {
                            onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
                            onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
                            onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
                            onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
                        };
                        var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
                        return _extends$2(_extends$2({
                            type: 'button',
                            role: 'button',
                            'aria-label': isOpen ? 'close menu' : 'open menu',
                            'aria-haspopup': true,
                            'data-toggle': true
                        }, eventHandlers), rest);
                    };

                    _this.buttonHandleKeyUp = function(event) {
                        // Prevent click event from emitting in Firefox
                        event.preventDefault();
                    };

                    _this.buttonHandleKeyDown = function(event) {
                        var key = normalizeArrowKey(event);

                        if (_this.buttonKeyDownHandlers[key]) {
                            _this.buttonKeyDownHandlers[key].call(_assertThisInitialized$2(_this), event);
                        }
                    };

                    _this.buttonHandleClick = function(event) {
                        event.preventDefault(); // handle odd case for Safari and Firefox which
                        // don't give the button the focus properly.

                        /* istanbul ignore if (can't reasonably test this) */

                        if (_this.props.environment.document.activeElement === _this.props.environment.document.body) {
                            event.target.focus();
                        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout
                        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated
                        // when building for production and should therefore have no impact on production code.


                        if (process.env.NODE_ENV === 'test') {
                            _this.toggleMenu({
                                type: clickButton
                            });
                        } else {
                            // Ensure that toggle of menu occurs after the potential blur event in iOS
                            _this.internalSetTimeout(function() {
                                return _this.toggleMenu({
                                    type: clickButton
                                });
                            });
                        }
                    };

                    _this.buttonHandleBlur = function(event) {
                        var blurTarget = event.target; // Save blur target for comparison with activeElement later
                        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element

                        _this.internalSetTimeout(function() {
                            if (!_this.isMouseDown && (_this.props.environment.document.activeElement == null || _this.props.environment.document.activeElement.id !== _this.inputId) && _this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)
                            ) {
                                _this.reset({
                                    type: blurButton
                                });
                            }
                        });
                    };

                    _this.getLabelProps = function(props) {
                        return _extends$2({
                            htmlFor: _this.inputId,
                            id: _this.labelId
                        }, props);
                    };

                    _this.getInputProps = function(_temp4) {
                        var _ref4 = _temp4 === void 0 ? {} : _temp4,
                            onKeyDown = _ref4.onKeyDown,
                            onBlur = _ref4.onBlur,
                            onChange = _ref4.onChange,
                            onInput = _ref4.onInput,
                            onChangeText = _ref4.onChangeText,
                            rest = _objectWithoutPropertiesLoose$1(_ref4, ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"]);

                        var onChangeKey;
                        var eventHandlers = {};
                        /* istanbul ignore next (preact) */

                        onChangeKey = 'onChange';

                        var _this$getState6 = _this.getState(),
                            inputValue = _this$getState6.inputValue,
                            isOpen = _this$getState6.isOpen,
                            highlightedIndex = _this$getState6.highlightedIndex;

                        if (!rest.disabled) {
                            var _eventHandlers;

                            eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
                        }
                        /* istanbul ignore if (react-native) */


                        return _extends$2(_extends$2({
                            'aria-autocomplete': 'list',
                            'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
                            'aria-controls': isOpen ? _this.menuId : null,
                            'aria-labelledby': _this.labelId,
                            // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
                            // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
                            autoComplete: 'off',
                            value: inputValue,
                            id: _this.inputId
                        }, eventHandlers), rest);
                    };

                    _this.inputHandleKeyDown = function(event) {
                        var key = normalizeArrowKey(event);

                        if (key && _this.inputKeyDownHandlers[key]) {
                            _this.inputKeyDownHandlers[key].call(_assertThisInitialized$2(_this), event);
                        }
                    };

                    _this.inputHandleChange = function(event) {
                        _this.internalSetState({
                            type: changeInput,
                            isOpen: true,
                            inputValue: event.target.value,
                            highlightedIndex: _this.props.defaultHighlightedIndex
                        });
                    };

                    _this.inputHandleBlur = function() {
                        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element
                        _this.internalSetTimeout(function() {
                            var downshiftButtonIsActive = _this.props.environment.document && !!_this.props.environment.document.activeElement && !!_this.props.environment.document.activeElement.dataset && _this.props.environment.document.activeElement.dataset.toggle && _this._rootNode && _this._rootNode.contains(_this.props.environment.document.activeElement);

                            if (!_this.isMouseDown && !downshiftButtonIsActive) {
                                _this.reset({
                                    type: blurInput
                                });
                            }
                        });
                    };

                    _this.menuRef = function(node) {
                        _this._menuNode = node;
                    };

                    _this.getMenuProps = function(_temp5, _temp6) {
                        var _extends3;

                        var _ref5 = _temp5 === void 0 ? {} : _temp5,
                            _ref5$refKey = _ref5.refKey,
                            refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
                            ref = _ref5.ref,
                            props = _objectWithoutPropertiesLoose$1(_ref5, ["refKey", "ref"]);

                        var _ref6 = _temp6 === void 0 ? {} : _temp6,
                            _ref6$suppressRefErro = _ref6.suppressRefError,
                            suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;

                        _this.getMenuProps.called = true;
                        _this.getMenuProps.refKey = refKey;
                        _this.getMenuProps.suppressRefError = suppressRefError;
                        return _extends$2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, _this.menuRef), _extends3.role = 'listbox', _extends3['aria-labelledby'] = props && props['aria-label'] ? null : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
                    };

                    _this.getItemProps = function(_temp7) {
                        var _enabledEventHandlers;

                        var _ref7 = _temp7 === void 0 ? {} : _temp7,
                            onMouseMove = _ref7.onMouseMove,
                            onMouseDown = _ref7.onMouseDown,
                            onClick = _ref7.onClick,
                            onPress = _ref7.onPress,
                            index = _ref7.index,
                            _ref7$item = _ref7.item,
                            item = _ref7$item === void 0 ? process.env.NODE_ENV === 'production' ?
                            /* istanbul ignore next */
                            undefined : requiredProp('getItemProps', 'item') : _ref7$item,
                            rest = _objectWithoutPropertiesLoose$1(_ref7, ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"]);

                        if (index === undefined) {
                            _this.items.push(item);

                            index = _this.items.indexOf(item);
                        } else {
                            _this.items[index] = item;
                        }

                        var onSelectKey = 'onClick';
                        var customClickHandler = onClick;
                        var enabledEventHandlers = (_enabledEventHandlers = {
                            // onMouseMove is used over onMouseEnter here. onMouseMove
                            // is only triggered on actual mouse movement while onMouseEnter
                            // can fire on DOM changes, interrupting keyboard navigation
                            onMouseMove: callAllEventHandlers(onMouseMove, function() {
                                if (index === _this.getState().highlightedIndex) {
                                    return;
                                }

                                _this.setHighlightedIndex(index, {
                                    type: itemMouseEnter
                                }); // We never want to manually scroll when changing state based
                                // on `onMouseMove` because we will be moving the element out
                                // from under the user which is currently scrolling/moving the
                                // cursor


                                _this.avoidScrolling = true;

                                _this.internalSetTimeout(function() {
                                    return _this.avoidScrolling = false;
                                }, 250);
                            }),
                            onMouseDown: callAllEventHandlers(onMouseDown, function(event) {
                                // This prevents the activeElement from being changed
                                // to the item so it can remain with the current activeElement
                                // which is a more common use case.
                                event.preventDefault();
                            })
                        }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function() {
                            _this.selectItemAtIndex(index, {
                                type: clickItem
                            });
                        }), _enabledEventHandlers); // Passing down the onMouseDown handler to prevent redirect
                        // of the activeElement if clicking on disabled items

                        var eventHandlers = rest.disabled ? {
                            onMouseDown: enabledEventHandlers.onMouseDown
                        } : enabledEventHandlers;
                        return _extends$2(_extends$2({
                            id: _this.getItemId(index),
                            role: 'option',
                            'aria-selected': _this.getState().highlightedIndex === index
                        }, eventHandlers), rest);
                    };

                    _this.clearItems = function() {
                        _this.items = [];
                    };

                    _this.reset = function(otherStateToSet, cb) {
                        if (otherStateToSet === void 0) {
                            otherStateToSet = {};
                        }

                        otherStateToSet = pickState(otherStateToSet);

                        _this.internalSetState(function(_ref8) {
                            var selectedItem = _ref8.selectedItem;
                            return _extends$2({
                                isOpen: _this.props.defaultIsOpen,
                                highlightedIndex: _this.props.defaultHighlightedIndex,
                                inputValue: _this.props.itemToString(selectedItem)
                            }, otherStateToSet);
                        }, cb);
                    };

                    _this.toggleMenu = function(otherStateToSet, cb) {
                        if (otherStateToSet === void 0) {
                            otherStateToSet = {};
                        }

                        otherStateToSet = pickState(otherStateToSet);

                        _this.internalSetState(function(_ref9) {
                            var isOpen = _ref9.isOpen;
                            return _extends$2(_extends$2({
                                isOpen: !isOpen
                            }, isOpen && {
                                highlightedIndex: _this.props.defaultHighlightedIndex
                            }), otherStateToSet);
                        }, function() {
                            var _this$getState7 = _this.getState(),
                                isOpen = _this$getState7.isOpen,
                                highlightedIndex = _this$getState7.highlightedIndex;

                            if (isOpen) {
                                if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {
                                    _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
                                }
                            }

                            cbToCb(cb)();
                        });
                    };

                    _this.openMenu = function(cb) {
                        _this.internalSetState({
                            isOpen: true
                        }, cb);
                    };

                    _this.closeMenu = function(cb) {
                        _this.internalSetState({
                            isOpen: false
                        }, cb);
                    };

                    _this.updateStatus = debounce$1(function() {
                        var state = _this.getState();

                        var item = _this.items[state.highlightedIndex];

                        var resultCount = _this.getItemCount();

                        var status = _this.props.getA11yStatusMessage(_extends$2({
                            itemToString: _this.props.itemToString,
                            previousResultCount: _this.previousResultCount,
                            resultCount: resultCount,
                            highlightedItem: item
                        }, state));

                        _this.previousResultCount = resultCount;
                        setStatus(status, _this.props.environment.document);
                    }, 200);

                    // fancy destructuring + defaults + aliases
                    // this basically says each value of state should either be set to
                    // the initial value or the default value if the initial value is not provided
                    var _this$props = _this.props,
                        defaultHighlightedIndex = _this$props.defaultHighlightedIndex,
                        _this$props$initialHi = _this$props.initialHighlightedIndex,
                        _highlightedIndex = _this$props$initialHi === void 0 ? defaultHighlightedIndex : _this$props$initialHi,
                        defaultIsOpen = _this$props.defaultIsOpen,
                        _this$props$initialIs = _this$props.initialIsOpen,
                        _isOpen = _this$props$initialIs === void 0 ? defaultIsOpen : _this$props$initialIs,
                        _this$props$initialIn = _this$props.initialInputValue,
                        _inputValue = _this$props$initialIn === void 0 ? '' : _this$props$initialIn,
                        _this$props$initialSe = _this$props.initialSelectedItem,
                        _selectedItem = _this$props$initialSe === void 0 ? null : _this$props$initialSe;

                    var _state = _this.getState({
                        highlightedIndex: _highlightedIndex,
                        isOpen: _isOpen,
                        inputValue: _inputValue,
                        selectedItem: _selectedItem
                    });

                    if (_state.selectedItem != null && _this.props.initialInputValue === undefined) {
                        _state.inputValue = _this.props.itemToString(_state.selectedItem);
                    }

                    _this.state = _state;
                    return _this;
                }

                var _proto = Downshift.prototype;

                /**
                 * Clear all running timeouts
                 */
                _proto.internalClearTimeouts = function internalClearTimeouts() {
                    this.timeoutIds.forEach(function(id) {
                        clearTimeout(id);
                    });
                    this.timeoutIds = [];
                }
                /**
                 * Gets the state based on internal state or props
                 * If a state value is passed via props, then that
                 * is the value given, otherwise it's retrieved from
                 * stateToMerge
                 *
                 * @param {Object} stateToMerge defaults to this.state
                 * @return {Object} the state
                 */
                ;

                _proto.getState = function getState$1(stateToMerge) {
                    if (stateToMerge === void 0) {
                        stateToMerge = this.state;
                    }

                    return getState(stateToMerge, this.props);
                };

                _proto.getItemCount = function getItemCount() {
                    // things read better this way. They're in priority order:
                    // 1. `this.itemCount`
                    // 2. `this.props.itemCount`
                    // 3. `this.items.length`
                    var itemCount = this.items.length;

                    if (this.itemCount != null) {
                        itemCount = this.itemCount;
                    } else if (this.props.itemCount !== undefined) {
                        itemCount = this.props.itemCount;
                    }

                    return itemCount;
                };

                _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index) {
                    return this.props.environment.document.getElementById(this.getItemId(index));
                };

                _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
                    /* istanbul ignore else (react-native) */
                    {
                        var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
                        this.props.scrollIntoView(node, this._menuNode);
                    }
                };

                _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
                    var _this6 = this;

                    var itemCount = this.getItemCount();

                    var _this$getState8 = this.getState(),
                        highlightedIndex = _this$getState8.highlightedIndex;

                    if (itemCount > 0) {
                        var nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, function(index) {
                            return _this6.getItemNodeFromIndex(index);
                        });
                        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
                    }
                };

                _proto.getStateAndHelpers = function getStateAndHelpers() {
                    var _this$getState9 = this.getState(),
                        highlightedIndex = _this$getState9.highlightedIndex,
                        inputValue = _this$getState9.inputValue,
                        selectedItem = _this$getState9.selectedItem,
                        isOpen = _this$getState9.isOpen;

                    var itemToString = this.props.itemToString;
                    var id = this.id;
                    var getRootProps = this.getRootProps,
                        getToggleButtonProps = this.getToggleButtonProps,
                        getLabelProps = this.getLabelProps,
                        getMenuProps = this.getMenuProps,
                        getInputProps = this.getInputProps,
                        getItemProps = this.getItemProps,
                        openMenu = this.openMenu,
                        closeMenu = this.closeMenu,
                        toggleMenu = this.toggleMenu,
                        selectItem = this.selectItem,
                        selectItemAtIndex = this.selectItemAtIndex,
                        selectHighlightedItem = this.selectHighlightedItem,
                        setHighlightedIndex = this.setHighlightedIndex,
                        clearSelection = this.clearSelection,
                        clearItems = this.clearItems,
                        reset = this.reset,
                        setItemCount = this.setItemCount,
                        unsetItemCount = this.unsetItemCount,
                        setState = this.internalSetState;
                    return {
                        // prop getters
                        getRootProps: getRootProps,
                        getToggleButtonProps: getToggleButtonProps,
                        getLabelProps: getLabelProps,
                        getMenuProps: getMenuProps,
                        getInputProps: getInputProps,
                        getItemProps: getItemProps,
                        // actions
                        reset: reset,
                        openMenu: openMenu,
                        closeMenu: closeMenu,
                        toggleMenu: toggleMenu,
                        selectItem: selectItem,
                        selectItemAtIndex: selectItemAtIndex,
                        selectHighlightedItem: selectHighlightedItem,
                        setHighlightedIndex: setHighlightedIndex,
                        clearSelection: clearSelection,
                        clearItems: clearItems,
                        setItemCount: setItemCount,
                        unsetItemCount: unsetItemCount,
                        setState: setState,
                        // props
                        itemToString: itemToString,
                        // derived
                        id: id,
                        // state
                        highlightedIndex: highlightedIndex,
                        inputValue: inputValue,
                        isOpen: isOpen,
                        selectedItem: selectedItem
                    };
                } //////////////////////////// ROOT
                ;

                _proto.componentDidMount = function componentDidMount() {
                    var _this7 = this;

                    /* istanbul ignore if (react-native) */
                    if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
                        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
                    }
                    /* istanbul ignore if (react-native) */


                    {
                        // this.isMouseDown helps us track whether the mouse is currently held down.
                        // This is useful when the user clicks on an item in the list, but holds the mouse
                        // down long enough for the list to disappear (because the blur event fires on the input)
                        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should
                        // trigger hiding the menu.
                        var onMouseDown = function() {
                            _this7.isMouseDown = true;
                        };

                        var onMouseUp = function(event) {
                            _this7.isMouseDown = false; // if the target element or the activeElement is within a downshift node
                            // then we don't want to reset downshift

                            var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment.document);

                            if (!contextWithinDownshift && _this7.getState().isOpen) {
                                _this7.reset({
                                    type: mouseUp
                                }, function() {
                                    return _this7.props.onOuterClick(_this7.getStateAndHelpers());
                                });
                            }
                        }; // Touching an element in iOS gives focus and hover states, but touching out of
                        // the element will remove hover, and persist the focus state, resulting in the
                        // blur event not being triggered.
                        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.
                        // If the user taps outside of Downshift, the component should be reset,
                        // but not if the user is swiping


                        var onTouchStart = function() {
                            _this7.isTouchMove = false;
                        };

                        var onTouchMove = function() {
                            _this7.isTouchMove = true;
                        };

                        var onTouchEnd = function(event) {
                            var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment.document, false);

                            if (!_this7.isTouchMove && !contextWithinDownshift && _this7.getState().isOpen) {
                                _this7.reset({
                                    type: touchEnd
                                }, function() {
                                    return _this7.props.onOuterClick(_this7.getStateAndHelpers());
                                });
                            }
                        };

                        var environment = this.props.environment;
                        environment.addEventListener('mousedown', onMouseDown);
                        environment.addEventListener('mouseup', onMouseUp);
                        environment.addEventListener('touchstart', onTouchStart);
                        environment.addEventListener('touchmove', onTouchMove);
                        environment.addEventListener('touchend', onTouchEnd);

                        this.cleanup = function() {
                            _this7.internalClearTimeouts();

                            _this7.updateStatus.cancel();

                            environment.removeEventListener('mousedown', onMouseDown);
                            environment.removeEventListener('mouseup', onMouseUp);
                            environment.removeEventListener('touchstart', onTouchStart);
                            environment.removeEventListener('touchmove', onTouchMove);
                            environment.removeEventListener('touchend', onTouchEnd);
                        };
                    }
                };

                _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
                    var _ref10 = this.props.highlightedIndex === undefined ? this.getState() : this.props,
                        currentHighlightedIndex = _ref10.highlightedIndex;

                    var _ref11 = prevProps.highlightedIndex === undefined ? prevState : prevProps,
                        prevHighlightedIndex = _ref11.highlightedIndex;

                    var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
                    return scrollWhenOpen || currentHighlightedIndex !== prevHighlightedIndex;
                };

                _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
                    if (process.env.NODE_ENV !== 'production') {
                        validateControlledUnchanged(this.state, prevProps, this.props);
                        /* istanbul ignore if (react-native) */

                        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
                            validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
                        }
                    }

                    if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
                        this.internalSetState({
                            type: controlledPropUpdatedSelectedItem,
                            inputValue: this.props.itemToString(this.props.selectedItem)
                        });
                    }

                    if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
                        this.scrollHighlightedItemIntoView();
                    }
                    /* istanbul ignore else (react-native) */


                    this.updateStatus();
                };

                _proto.componentWillUnmount = function componentWillUnmount() {
                    this.cleanup(); // avoids memory leak
                };

                _proto.render = function render() {
                    var children = unwrapArray$1(this.props.children, noop); // because the items are rerendered every time we call the children
                    // we clear this out each render and it will be populated again as
                    // getItemProps is called.

                    this.clearItems(); // we reset this so we know whether the user calls getRootProps during
                    // this render. If they do then we don't need to do anything,
                    // if they don't then we need to clone the element they return and
                    // apply the props for them.

                    this.getRootProps.called = false;
                    this.getRootProps.refKey = undefined;
                    this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps

                    this.getMenuProps.called = false;
                    this.getMenuProps.refKey = undefined;
                    this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps

                    this.getLabelProps.called = false; // and something similar for getInputProps

                    this.getInputProps.called = false;
                    var element = unwrapArray$1(children(this.getStateAndHelpers()));

                    if (!element) {
                        return null;
                    }

                    if (this.getRootProps.called || this.props.suppressRefError) {
                        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {
                            validateGetRootPropsCalledCorrectly(element, this.getRootProps);
                        }

                        return element;
                    } else if (isDOMElement(element)) {
                        // they didn't apply the root props, but we can clone
                        // this and apply the props ourselves
                        return React.cloneElement(element, this.getRootProps(getElementProps(element)));
                    }
                    /* istanbul ignore else */


                    if (process.env.NODE_ENV !== 'production') {
                        // they didn't apply the root props, but they need to
                        // otherwise we can't query around the autocomplete
                        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');
                    }
                    /* istanbul ignore next */


                    return undefined;
                };

                return Downshift;
            }(React.Component);

        Downshift.defaultProps = {
            defaultHighlightedIndex: null,
            defaultIsOpen: false,
            getA11yStatusMessage: getA11yStatusMessage,
            itemToString: function itemToString(i) {
                if (i == null) {
                    return '';
                }

                if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {
                    // eslint-disable-next-line no-console
                    console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);
                }

                return String(i);
            },
            onStateChange: noop,
            onInputValueChange: noop,
            onUserAction: noop,
            onChange: noop,
            onSelect: noop,
            onOuterClick: noop,
            selectedItemChanged: function selectedItemChanged(prevItem, item) {
                return prevItem !== item;
            },
            environment: typeof window === 'undefined'
                /* istanbul ignore next (ssr) */
                ?
                {} : window,
            stateReducer: function stateReducer(state, stateToSet) {
                return stateToSet;
            },
            suppressRefError: false,
            scrollIntoView: scrollIntoView
        };
        Downshift.stateChangeTypes = stateChangeTypes;
        return Downshift;
    }();

process.env.NODE_ENV !== "production" ? Downshift.propTypes = {
    children: PropTypes.func,
    defaultHighlightedIndex: PropTypes.number,
    defaultIsOpen: PropTypes.bool,
    initialHighlightedIndex: PropTypes.number,
    initialSelectedItem: PropTypes.any,
    initialInputValue: PropTypes.string,
    initialIsOpen: PropTypes.bool,
    getA11yStatusMessage: PropTypes.func,
    itemToString: PropTypes.func,
    onChange: PropTypes.func,
    onSelect: PropTypes.func,
    onStateChange: PropTypes.func,
    onInputValueChange: PropTypes.func,
    onUserAction: PropTypes.func,
    onOuterClick: PropTypes.func,
    selectedItemChanged: PropTypes.func,
    stateReducer: PropTypes.func,
    itemCount: PropTypes.number,
    id: PropTypes.string,
    environment: PropTypes.shape({
        addEventListener: PropTypes.func,
        removeEventListener: PropTypes.func,
        document: PropTypes.shape({
            getElementById: PropTypes.func,
            activeElement: PropTypes.any,
            body: PropTypes.any
        })
    }),
    suppressRefError: PropTypes.bool,
    scrollIntoView: PropTypes.func,
    // things we keep in state for uncontrolled components
    // but can accept as props for controlled components

    /* eslint-disable react/no-unused-prop-types */
    selectedItem: PropTypes.any,
    isOpen: PropTypes.bool,
    inputValue: PropTypes.string,
    highlightedIndex: PropTypes.number,
    labelId: PropTypes.string,
    inputId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func
    /* eslint-enable react/no-unused-prop-types */

} : void 0;

function validateGetMenuPropsCalledCorrectly(node, _ref12) {
    var refKey = _ref12.refKey;

    if (!node) {
        // eslint-disable-next-line no-console
        console.error("downshift: The ref prop \"" + refKey + "\" from getMenuProps was not applied correctly on your menu element.");
    }
}

function validateGetRootPropsCalledCorrectly(element, _ref13) {
    var refKey = _ref13.refKey;
    var refKeySpecified = refKey !== 'ref';
    var isComposite = !isDOMElement(element);

    if (isComposite && !refKeySpecified && !reactIs.isForwardRef(element)) {
        // eslint-disable-next-line no-console
        console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');
    } else if (!isComposite && refKeySpecified) {
        // eslint-disable-next-line no-console
        console.error("downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"" + refKey + "\"");
    }

    if (!reactIs.isForwardRef(element) && !getElementProps(element)[refKey]) {
        // eslint-disable-next-line no-console
        console.error("downshift: You must apply the ref prop \"" + refKey + "\" from getRootProps onto your root element.");
    }
}

var dropdownDefaultStateValues = {
    highlightedIndex: -1,
    isOpen: false,
    selectedItem: null,
    inputValue: ''
};

function callOnChangeProps(action, state, newState) {
    var props = action.props,
        type = action.type;
    var changes = {};
    Object.keys(state).forEach(function(key) {
        invokeOnChangeHandler(key, props, state, newState);

        if (newState[key] !== state[key]) {
            changes[key] = newState[key];
        }
    });

    if (props.onStateChange && Object.keys(changes).length) {
        props.onStateChange(_extends$2({
            type: type
        }, changes));
    }
}

function invokeOnChangeHandler(key, props, state, newState) {
    var handler = "on" + capitalizeString(key) + "Change";

    if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {
        props[handler](newState);
    }
}
/**
 * Default state reducer that returns the changes.
 *
 * @param {Object} s state.
 * @param {Object} a action with changes.
 * @returns {Object} changes.
 */


function stateReducer(s, a) {
    return a.changes;
}
/**
 * Returns a message to be added to aria-live region when item is selected.
 *
 * @param {Object} selectionParameters Parameters required to build the message.
 * @returns {string} The a11y message.
 */


function getA11ySelectionMessage(selectionParameters) {
    var selectedItem = selectionParameters.selectedItem,
        itemToStringLocal = selectionParameters.itemToString;
    return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : '';
}
/**
 * Debounced call for updating the a11y message.
 */


var updateA11yStatus = debounce$1(function(getA11yMessage, document) {
    setStatus(getA11yMessage(), document);
}, 200);

function getElementIds(_ref) {
    var id = _ref.id,
        labelId = _ref.labelId,
        menuId = _ref.menuId,
        getItemId = _ref.getItemId,
        toggleButtonId = _ref.toggleButtonId;
    var uniqueId = id === undefined ? "downshift-" + generateId() : id;
    return {
        labelId: labelId || uniqueId + "-label",
        menuId: menuId || uniqueId + "-menu",
        getItemId: getItemId || function(index) {
            return uniqueId + "-item-" + index;
        },
        toggleButtonId: toggleButtonId || uniqueId + "-toggle-button"
    };
}

function getItemIndex(index, item, items) {
    if (index !== undefined) {
        return index;
    }

    if (items.length === 0) {
        return -1;
    }

    return items.indexOf(item);
}

function itemToString(item) {
    return item ? String(item) : '';
}

function getPropTypesValidator(caller, propTypes) {
    // istanbul ignore next
    return function(options) {
        if (options === void 0) {
            options = {};
        }

        Object.keys(propTypes).forEach(function(key) {
            PropTypes.checkPropTypes(propTypes, options, key, caller.name);
        });
    };
}

function isAcceptedCharacterKey(key) {
    return /^\S{1}$/.test(key);
}

function capitalizeString(string) {
    return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
}

function useLatestRef(val) {
    var ref = React.useRef(val); // technically this is not "concurrent mode safe" because we're manipulating
    // the value during render (so it's not idempotent). However, the places this
    // hook is used is to support memoizing callbacks which will be called
    // *during* render, so we need the latest values *during* render.
    // If not for this, then we'd probably want to use useLayoutEffect instead.

    ref.current = val;
    return ref;
}
/**
 * Computes the controlled state using a the previous state, props,
 * two reducers, one from downshift and an optional one from the user.
 * Also calls the onChange handlers for state values that have changed.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */

function useEnhancedReducer(reducer, initialState, props) {
    var prevStateRef = React.useRef();
    var actionRef = React.useRef();
    var enhancedReducer = React.useCallback(function(state, action) {
        actionRef.current = action;
        state = getState(state, action.props);
        var changes = reducer(state, action);
        var newState = action.props.stateReducer(state, _extends$2(_extends$2({}, action), {}, {
            changes: changes
        }));
        return newState;
    }, [reducer]);

    var _useReducer = React.useReducer(enhancedReducer, initialState),
        state = _useReducer[0],
        dispatch = _useReducer[1];

    var propsRef = useLatestRef(props);
    var dispatchWithProps = React.useCallback(function(action) {
        return dispatch(_extends$2({
            props: propsRef.current
        }, action));
    }, [propsRef]);
    var action = actionRef.current;
    React.useEffect(function() {
        if (action && prevStateRef.current && prevStateRef.current !== state) {
            callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
        }

        prevStateRef.current = state;
    }, [state, props, action]);
    return [state, dispatchWithProps];
}
/**
 * Wraps the useEnhancedReducer and applies the controlled prop values before
 * returning the new state.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */

function useControlledReducer(reducer, initialState, props) {
    var _useEnhancedReducer = useEnhancedReducer(reducer, initialState, props),
        state = _useEnhancedReducer[0],
        dispatch = _useEnhancedReducer[1];

    return [getState(state, props), dispatch];
}
var defaultProps = {
    itemToString: itemToString,
    stateReducer: stateReducer,
    getA11ySelectionMessage: getA11ySelectionMessage,
    scrollIntoView: scrollIntoView,
    circularNavigation: false,
    environment: typeof window === 'undefined'
        /* istanbul ignore next (ssr) */
        ?
        {} : window
};

function getDefaultValue(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
        defaultStateValues = dropdownDefaultStateValues;
    }

    var defaultPropKey = "default" + capitalizeString(propKey);

    if (defaultPropKey in props) {
        return props[defaultPropKey];
    }

    return defaultStateValues[propKey];
}

function getInitialValue(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
        defaultStateValues = dropdownDefaultStateValues;
    }

    if (propKey in props) {
        return props[propKey];
    }

    var initialPropKey = "initial" + capitalizeString(propKey);

    if (initialPropKey in props) {
        return props[initialPropKey];
    }

    return getDefaultValue(props, propKey, defaultStateValues);
}

function getInitialState(props) {
    var selectedItem = getInitialValue(props, 'selectedItem');
    var isOpen = getInitialValue(props, 'isOpen');
    var highlightedIndex = getInitialValue(props, 'highlightedIndex');
    var inputValue = getInitialValue(props, 'inputValue');
    return {
        highlightedIndex: highlightedIndex < 0 && selectedItem ? props.items.indexOf(selectedItem) : highlightedIndex,
        isOpen: isOpen,
        selectedItem: selectedItem,
        inputValue: inputValue
    };
}

function getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {
    var items = props.items,
        initialHighlightedIndex = props.initialHighlightedIndex,
        defaultHighlightedIndex = props.defaultHighlightedIndex;
    var selectedItem = state.selectedItem,
        highlightedIndex = state.highlightedIndex;

    if (items.length === 0) {
        return -1;
    } // initialHighlightedIndex will give value to highlightedIndex on initial state only.


    if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {
        return initialHighlightedIndex;
    }

    if (defaultHighlightedIndex !== undefined) {
        return defaultHighlightedIndex;
    }

    if (selectedItem) {
        if (offset === 0) {
            return items.indexOf(selectedItem);
        }

        return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);
    }

    if (offset === 0) {
        return -1;
    }

    return offset < 0 ? items.length - 1 : 0;
}
/**
 * Reuse the movement tracking of mouse and touch events.
 *
 * @param {boolean} isOpen Whether the dropdown is open or not.
 * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)
 * @param {Object} environment Environment where component/hook exists.
 * @param {Function} handleBlur Handler on blur from mouse or touch.
 * @returns {Object} Ref containing whether mouseDown or touchMove event is happening
 */

function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
    var mouseAndTouchTrackersRef = React.useRef({
        isMouseDown: false,
        isTouchMove: false
    });
    React.useEffect(function() {
        // The same strategy for checking if a click occurred inside or outside downsift
        // as in downshift.js.
        var onMouseDown = function() {
            mouseAndTouchTrackersRef.current.isMouseDown = true;
        };

        var onMouseUp = function(event) {
            mouseAndTouchTrackersRef.current.isMouseDown = false;

            if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref) {
                    return ref.current;
                }), environment.document)) {
                handleBlur();
            }
        };

        var onTouchStart = function() {
            mouseAndTouchTrackersRef.current.isTouchMove = false;
        };

        var onTouchMove = function() {
            mouseAndTouchTrackersRef.current.isTouchMove = true;
        };

        var onTouchEnd = function(event) {
            if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref) {
                    return ref.current;
                }), environment.document, false)) {
                handleBlur();
            }
        };

        environment.addEventListener('mousedown', onMouseDown);
        environment.addEventListener('mouseup', onMouseUp);
        environment.addEventListener('touchstart', onTouchStart);
        environment.addEventListener('touchmove', onTouchMove);
        environment.addEventListener('touchend', onTouchEnd);
        return function() {
            environment.removeEventListener('mousedown', onMouseDown);
            environment.removeEventListener('mouseup', onMouseUp);
            environment.removeEventListener('touchstart', onTouchStart);
            environment.removeEventListener('touchmove', onTouchMove);
            environment.removeEventListener('touchend', onTouchEnd);
        }; // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen, environment]);
    return mouseAndTouchTrackersRef;
}
/**
 * Custom hook that checks if getter props are called correctly.
 *
 * @param  {...any} propKeys Getter prop names to be handled.
 * @returns {Function} Setter function called inside getter props to set call information.
 */

function useGetterPropsCalledChecker() {
    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {
        propKeys[_key] = arguments[_key];
    }

    var getterPropsCalledRef = React.useRef(propKeys.reduce(function(acc, propKey) {
        acc[propKey] = {};
        return acc;
    }, {}));

    if (process.env.NODE_ENV !== 'production') {
        Object.keys(getterPropsCalledRef.current).forEach(function(propKey) {
            getterPropsCalledRef.current[propKey] = null;
        });
    }

    React.useEffect(function() {
        if (process.env.NODE_ENV !== 'production') {
            Object.keys(getterPropsCalledRef.current).forEach(function(propKey) {
                if (!getterPropsCalledRef.current[propKey]) {
                    // eslint-disable-next-line no-console
                    console.error("downshift: You forgot to call the " + propKey + " getter function on your component / element.");
                    return;
                }

                var _getterPropsCalledRef = getterPropsCalledRef.current[propKey],
                    suppressRefError = _getterPropsCalledRef.suppressRefError,
                    refKey = _getterPropsCalledRef.refKey,
                    elementRef = _getterPropsCalledRef.elementRef;

                if ((!elementRef || !elementRef.current) && !suppressRefError) {
                    // eslint-disable-next-line no-console
                    console.error("downshift: The ref prop \"" + refKey + "\" from " + propKey + " was not applied correctly on your element.");
                }
            });
        }
    });
    var setGetterPropCallInfo = React.useCallback(function(propKey, suppressRefError, refKey, elementRef) {
        if (process.env.NODE_ENV !== 'production') {
            getterPropsCalledRef.current[propKey] = {
                suppressRefError: suppressRefError,
                refKey: refKey,
                elementRef: elementRef
            };
        }
    }, []);
    return setGetterPropCallInfo;
}

function getItemIndexByCharacterKey(keysSoFar, highlightedIndex, items, itemToStringParam, getItemNodeFromIndex) {
    var lowerCasedItemStrings = items.map(function(item) {
        return itemToStringParam(item).toLowerCase();
    });
    var lowerCasedKeysSoFar = keysSoFar.toLowerCase();

    var isValid = function(itemString, index) {
        var element = getItemNodeFromIndex(index);
        return itemString.startsWith(lowerCasedKeysSoFar) && !(element && element.hasAttribute('disabled'));
    };

    for (var index = highlightedIndex + 1; index < lowerCasedItemStrings.length; index++) {
        var itemString = lowerCasedItemStrings[index];

        if (isValid(itemString, index)) {
            return index;
        }
    }

    for (var _index = 0; _index < highlightedIndex; _index++) {
        var _itemString = lowerCasedItemStrings[_index];

        if (isValid(_itemString, _index)) {
            return _index;
        }
    }

    return highlightedIndex;
}

var propTypes = {
    items: PropTypes.array.isRequired,
    itemToString: PropTypes.func,
    getA11yStatusMessage: PropTypes.func,
    getA11ySelectionMessage: PropTypes.func,
    circularNavigation: PropTypes.bool,
    highlightedIndex: PropTypes.number,
    defaultHighlightedIndex: PropTypes.number,
    initialHighlightedIndex: PropTypes.number,
    isOpen: PropTypes.bool,
    defaultIsOpen: PropTypes.bool,
    initialIsOpen: PropTypes.bool,
    selectedItem: PropTypes.any,
    initialSelectedItem: PropTypes.any,
    defaultSelectedItem: PropTypes.any,
    id: PropTypes.string,
    labelId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func,
    toggleButtonId: PropTypes.string,
    stateReducer: PropTypes.func,
    onSelectedItemChange: PropTypes.func,
    onHighlightedIndexChange: PropTypes.func,
    onStateChange: PropTypes.func,
    onIsOpenChange: PropTypes.func,
    environment: PropTypes.shape({
        addEventListener: PropTypes.func,
        removeEventListener: PropTypes.func,
        document: PropTypes.shape({
            getElementById: PropTypes.func,
            activeElement: PropTypes.any,
            body: PropTypes.any
        })
    })
};
/**
 * Default implementation for status message. Only added when menu is open.
 * Will specift if there are results in the list, and if so, how many,
 * and what keys are relevant.
 *
 * @param {Object} param the downshift state and other relevant properties
 * @return {String} the a11y status message
 */

function getA11yStatusMessage$1(_ref) {
    var isOpen = _ref.isOpen,
        resultCount = _ref.resultCount,
        previousResultCount = _ref.previousResultCount;

    if (!isOpen) {
        return '';
    }

    if (!resultCount) {
        return 'No results are available.';
    }

    if (resultCount !== previousResultCount) {
        return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.";
    }

    return '';
}

var defaultProps$1 = _extends$2(_extends$2({}, defaultProps), {}, {
    getA11yStatusMessage: getA11yStatusMessage$1
});

var MenuKeyDownArrowDown = process.env.NODE_ENV !== "production" ? '__menu_keydown_arrow_down__' : 0;
var MenuKeyDownArrowUp = process.env.NODE_ENV !== "production" ? '__menu_keydown_arrow_up__' : 1;
var MenuKeyDownEscape = process.env.NODE_ENV !== "production" ? '__menu_keydown_escape__' : 2;
var MenuKeyDownHome = process.env.NODE_ENV !== "production" ? '__menu_keydown_home__' : 3;
var MenuKeyDownEnd = process.env.NODE_ENV !== "production" ? '__menu_keydown_end__' : 4;
var MenuKeyDownEnter = process.env.NODE_ENV !== "production" ? '__menu_keydown_enter__' : 5;
var MenuKeyDownSpaceButton = process.env.NODE_ENV !== "production" ? '__menu_keydown_space_button__' : 6;
var MenuKeyDownCharacter = process.env.NODE_ENV !== "production" ? '__menu_keydown_character__' : 7;
var MenuBlur = process.env.NODE_ENV !== "production" ? '__menu_blur__' : 8;
var MenuMouseLeave = process.env.NODE_ENV !== "production" ? '__menu_mouse_leave__' : 9;
var ItemMouseMove = process.env.NODE_ENV !== "production" ? '__item_mouse_move__' : 10;
var ItemClick = process.env.NODE_ENV !== "production" ? '__item_click__' : 11;
var ToggleButtonClick = process.env.NODE_ENV !== "production" ? '__togglebutton_click__' : 12;
var ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_arrow_down__' : 13;
var ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_arrow_up__' : 14;
var ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_character__' : 15;
var FunctionToggleMenu = process.env.NODE_ENV !== "production" ? '__function_toggle_menu__' : 16;
var FunctionOpenMenu = process.env.NODE_ENV !== "production" ? '__function_open_menu__' : 17;
var FunctionCloseMenu = process.env.NODE_ENV !== "production" ? '__function_close_menu__' : 18;
var FunctionSetHighlightedIndex = process.env.NODE_ENV !== "production" ? '__function_set_highlighted_index__' : 19;
var FunctionSelectItem = process.env.NODE_ENV !== "production" ? '__function_select_item__' : 20;
var FunctionSetInputValue = process.env.NODE_ENV !== "production" ? '__function_set_input_value__' : 21;
var FunctionReset = process.env.NODE_ENV !== "production" ? '__function_reset__' : 22;

var stateChangeTypes$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    MenuKeyDownArrowDown: MenuKeyDownArrowDown,
    MenuKeyDownArrowUp: MenuKeyDownArrowUp,
    MenuKeyDownEscape: MenuKeyDownEscape,
    MenuKeyDownHome: MenuKeyDownHome,
    MenuKeyDownEnd: MenuKeyDownEnd,
    MenuKeyDownEnter: MenuKeyDownEnter,
    MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,
    MenuKeyDownCharacter: MenuKeyDownCharacter,
    MenuBlur: MenuBlur,
    MenuMouseLeave: MenuMouseLeave,
    ItemMouseMove: ItemMouseMove,
    ItemClick: ItemClick,
    ToggleButtonClick: ToggleButtonClick,
    ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,
    ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,
    ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,
    FunctionToggleMenu: FunctionToggleMenu,
    FunctionOpenMenu: FunctionOpenMenu,
    FunctionCloseMenu: FunctionCloseMenu,
    FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,
    FunctionSelectItem: FunctionSelectItem,
    FunctionSetInputValue: FunctionSetInputValue,
    FunctionReset: FunctionReset
});

/* eslint-disable complexity */

function downshiftSelectReducer(state, action) {
    var type = action.type,
        props = action.props,
        shiftKey = action.shiftKey;
    var changes;

    switch (type) {
        case ItemMouseMove:
            changes = {
                highlightedIndex: action.index
            };
            break;

        case ItemClick:
            changes = {
                isOpen: getDefaultValue(props, 'isOpen'),
                highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
                selectedItem: props.items[action.index]
            };
            break;

        case ToggleButtonKeyDownCharacter:
            {
                var lowercasedKey = action.key;
                var inputValue = "" + state.inputValue + lowercasedKey;
                var itemIndex = getItemIndexByCharacterKey(inputValue, state.selectedItem ? props.items.indexOf(state.selectedItem) : -1, props.items, props.itemToString, action.getItemNodeFromIndex);
                changes = _extends$2({
                    inputValue: inputValue
                }, itemIndex >= 0 && {
                    selectedItem: props.items[itemIndex]
                });
            }
            break;

        case ToggleButtonKeyDownArrowDown:
            changes = {
                highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
                isOpen: true
            };
            break;

        case ToggleButtonKeyDownArrowUp:
            changes = {
                highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
                isOpen: true
            };
            break;

        case MenuKeyDownEnter:
        case MenuKeyDownSpaceButton:
            changes = _extends$2({
                isOpen: getDefaultValue(props, 'isOpen'),
                highlightedIndex: getDefaultValue(props, 'highlightedIndex')
            }, state.highlightedIndex >= 0 && {
                selectedItem: props.items[state.highlightedIndex]
            });
            break;

        case MenuKeyDownHome:
            changes = {
                highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
            };
            break;

        case MenuKeyDownEnd:
            changes = {
                highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
            };
            break;

        case MenuKeyDownEscape:
            changes = {
                isOpen: false,
                highlightedIndex: -1
            };
            break;

        case MenuBlur:
            changes = {
                isOpen: false,
                highlightedIndex: -1
            };
            break;

        case MenuKeyDownCharacter:
            {
                var _lowercasedKey = action.key;

                var _inputValue = "" + state.inputValue + _lowercasedKey;

                var highlightedIndex = getItemIndexByCharacterKey(_inputValue, state.highlightedIndex, props.items, props.itemToString, action.getItemNodeFromIndex);
                changes = _extends$2({
                    inputValue: _inputValue
                }, highlightedIndex >= 0 && {
                    highlightedIndex: highlightedIndex
                });
            }
            break;

        case MenuKeyDownArrowDown:
            changes = {
                highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
            };
            break;

        case MenuKeyDownArrowUp:
            changes = {
                highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
            };
            break;

        case MenuMouseLeave:
            changes = {
                highlightedIndex: -1
            };
            break;

        case ToggleButtonClick:
        case FunctionToggleMenu:
            changes = {
                isOpen: !state.isOpen,
                highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
            };
            break;

        case FunctionOpenMenu:
            changes = {
                isOpen: true,
                highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
            };
            break;

        case FunctionCloseMenu:
            changes = {
                isOpen: false
            };
            break;

        case FunctionSetHighlightedIndex:
            changes = {
                highlightedIndex: action.highlightedIndex
            };
            break;

        case FunctionSelectItem:
            changes = {
                selectedItem: action.selectedItem
            };
            break;

        case FunctionSetInputValue:
            changes = {
                inputValue: action.inputValue
            };
            break;

        case FunctionReset:
            changes = {
                highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
                isOpen: getDefaultValue(props, 'isOpen'),
                selectedItem: getDefaultValue(props, 'selectedItem'),
                inputValue: getDefaultValue(props, 'inputValue')
            };
            break;

        default:
            throw new Error('Reducer called without proper action type.');
    }

    return _extends$2(_extends$2({}, state), changes);
}
/* eslint-enable complexity */

var validatePropTypes = process.env.NODE_ENV === 'production' ?
    /* istanbul ignore next */
    null : getPropTypesValidator(useSelect, propTypes);
useSelect.stateChangeTypes = stateChangeTypes$1;

function useSelect(userProps) {
    if (userProps === void 0) {
        userProps = {};
    }

    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
        validatePropTypes(userProps);
    } // Props defaults and destructuring.


    var props = _extends$2(_extends$2({}, defaultProps$1), userProps);

    var items = props.items,
        scrollIntoView = props.scrollIntoView,
        environment = props.environment,
        initialIsOpen = props.initialIsOpen,
        defaultIsOpen = props.defaultIsOpen,
        itemToString = props.itemToString,
        getA11ySelectionMessage = props.getA11ySelectionMessage,
        getA11yStatusMessage = props.getA11yStatusMessage; // Initial state depending on controlled props.

    var initialState = getInitialState(props);

    var _useControlledReducer = useControlledReducer(downshiftSelectReducer, initialState, props),
        state = _useControlledReducer[0],
        dispatch = _useControlledReducer[1];

    var isOpen = state.isOpen,
        highlightedIndex = state.highlightedIndex,
        selectedItem = state.selectedItem,
        inputValue = state.inputValue; // Element efs.

    var toggleButtonRef = React.useRef(null);
    var menuRef = React.useRef(null);
    var itemRefs = React.useRef();
    itemRefs.current = {}; // used not to scroll when highlight by mouse.

    var shouldScrollRef = React.useRef(true); // used not to trigger menu blur action in some scenarios.

    var shouldBlurRef = React.useRef(true); // used to keep the inputValue clearTimeout object between renders.

    var clearTimeoutRef = React.useRef(null); // prevent id re-generation between renders.

    var elementIdsRef = React.useRef(getElementIds(props)); // used to keep track of how many items we had on previous cycle.

    var previousResultCountRef = React.useRef();
    var isInitialMountRef = React.useRef(true); // used for checking when props are moving from controlled to uncontrolled.

    var prevPropsRef = React.useRef(props); // utility callback to get item element.

    var latest = useLatestRef({
        state: state,
        props: props
    }); // Some utils.

    var getItemNodeFromIndex = function(index) {
        return itemRefs.current[elementIdsRef.current.getItemId(index)];
    }; // Effects.
    // Sets a11y status message on changes in state.


    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        var previousResultCount = previousResultCountRef.current;
        updateA11yStatus(function() {
            return getA11yStatusMessage({
                isOpen: isOpen,
                highlightedIndex: highlightedIndex,
                selectedItem: selectedItem,
                inputValue: inputValue,
                highlightedItem: items[highlightedIndex],
                resultCount: items.length,
                itemToString: itemToString,
                previousResultCount: previousResultCount
            });
        }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen, highlightedIndex, inputValue, items]); // Sets a11y status message on changes in selectedItem.

    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        var previousResultCount = previousResultCountRef.current;
        updateA11yStatus(function() {
            return getA11ySelectionMessage({
                isOpen: isOpen,
                highlightedIndex: highlightedIndex,
                selectedItem: selectedItem,
                inputValue: inputValue,
                highlightedItem: items[highlightedIndex],
                resultCount: items.length,
                itemToString: itemToString,
                previousResultCount: previousResultCount
            });
        }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectedItem]); // Sets cleanup for the keysSoFar after 500ms.

    React.useEffect(function() {
        // init the clean function here as we need access to dispatch.
        if (isInitialMountRef.current) {
            clearTimeoutRef.current = debounce$1(function(outerDispatch) {
                outerDispatch({
                    type: FunctionSetInputValue,
                    inputValue: ''
                });
            }, 500);
        }

        if (!inputValue) {
            return;
        }

        clearTimeoutRef.current(dispatch); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [inputValue]);
    /* Controls the focus on the menu or the toggle button. */

    React.useEffect(function() {
        // Don't focus menu on first render.
        if (isInitialMountRef.current) {
            // Unless it was initialised as open.
            if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {
                menuRef.current.focus();
            }

            return;
        } // Focus menu on open.


        if (isOpen) {
            // istanbul ignore else
            if (menuRef.current) {
                menuRef.current.focus();
            }

            return;
        } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.


        if (environment.document.activeElement === menuRef.current) {
            // istanbul ignore else
            if (toggleButtonRef.current) {
                shouldBlurRef.current = false;
                toggleButtonRef.current.focus();
            }
        } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [isOpen]); // Scroll on highlighted item if change comes from keyboard.

    React.useEffect(function() {
        if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
            return;
        }

        if (shouldScrollRef.current === false) {
            shouldScrollRef.current = true;
        } else {
            scrollIntoView(getItemNodeFromIndex(highlightedIndex), menuRef.current);
        } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [highlightedIndex]);
    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        previousResultCountRef.current = items.length;
    });
    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        validateControlledUnchanged(state, prevPropsRef.current, props);
        prevPropsRef.current = props;
    }, [state, props]); // Add mouse/touch events to document.

    var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, function() {
        dispatch({
            type: MenuBlur
        });
    });
    var setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.

    React.useEffect(function() {
        isInitialMountRef.current = false;
    }, []); // Event handler functions.

    var toggleButtonKeyDownHandlers = React.useMemo(function() {
        return {
            ArrowDown: function ArrowDown(event) {
                event.preventDefault();
                dispatch({
                    type: ToggleButtonKeyDownArrowDown,
                    getItemNodeFromIndex: getItemNodeFromIndex,
                    shiftKey: event.shiftKey
                });
            },
            ArrowUp: function ArrowUp(event) {
                event.preventDefault();
                dispatch({
                    type: ToggleButtonKeyDownArrowUp,
                    getItemNodeFromIndex: getItemNodeFromIndex,
                    shiftKey: event.shiftKey
                });
            }
        };
    }, [dispatch]);
    var menuKeyDownHandlers = React.useMemo(function() {
        return {
            ArrowDown: function ArrowDown(event) {
                event.preventDefault();
                dispatch({
                    type: MenuKeyDownArrowDown,
                    getItemNodeFromIndex: getItemNodeFromIndex,
                    shiftKey: event.shiftKey
                });
            },
            ArrowUp: function ArrowUp(event) {
                event.preventDefault();
                dispatch({
                    type: MenuKeyDownArrowUp,
                    getItemNodeFromIndex: getItemNodeFromIndex,
                    shiftKey: event.shiftKey
                });
            },
            Home: function Home(event) {
                event.preventDefault();
                dispatch({
                    type: MenuKeyDownHome,
                    getItemNodeFromIndex: getItemNodeFromIndex
                });
            },
            End: function End(event) {
                event.preventDefault();
                dispatch({
                    type: MenuKeyDownEnd,
                    getItemNodeFromIndex: getItemNodeFromIndex
                });
            },
            Escape: function Escape() {
                dispatch({
                    type: MenuKeyDownEscape
                });
            },
            Enter: function Enter(event) {
                event.preventDefault();
                dispatch({
                    type: MenuKeyDownEnter
                });
            },
            ' ': function _(event) {
                event.preventDefault();
                dispatch({
                    type: MenuKeyDownSpaceButton
                });
            }
        };
    }, [dispatch]); // Action functions.

    var toggleMenu = React.useCallback(function() {
        dispatch({
            type: FunctionToggleMenu
        });
    }, [dispatch]);
    var closeMenu = React.useCallback(function() {
        dispatch({
            type: FunctionCloseMenu
        });
    }, [dispatch]);
    var openMenu = React.useCallback(function() {
        dispatch({
            type: FunctionOpenMenu
        });
    }, [dispatch]);
    var setHighlightedIndex = React.useCallback(function(newHighlightedIndex) {
        dispatch({
            type: FunctionSetHighlightedIndex,
            highlightedIndex: newHighlightedIndex
        });
    }, [dispatch]);
    var selectItem = React.useCallback(function(newSelectedItem) {
        dispatch({
            type: FunctionSelectItem,
            selectedItem: newSelectedItem
        });
    }, [dispatch]);
    var reset = React.useCallback(function() {
        dispatch({
            type: FunctionReset
        });
    }, [dispatch]);
    var setInputValue = React.useCallback(function(newInputValue) {
        dispatch({
            type: FunctionSetInputValue,
            inputValue: newInputValue
        });
    }, [dispatch]); // Getter functions.

    var getLabelProps = React.useCallback(function(labelProps) {
        return _extends$2({
            id: elementIdsRef.current.labelId,
            htmlFor: elementIdsRef.current.toggleButtonId
        }, labelProps);
    }, []);
    var getMenuProps = React.useCallback(function(_temp, _temp2) {
        var _extends2;

        var _ref = _temp === void 0 ? {} : _temp,
            onMouseLeave = _ref.onMouseLeave,
            _ref$refKey = _ref.refKey,
            refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
            onKeyDown = _ref.onKeyDown,
            onBlur = _ref.onBlur,
            ref = _ref.ref,
            rest = _objectWithoutPropertiesLoose$1(_ref, ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"]);

        var _ref2 = _temp2 === void 0 ? {} : _temp2,
            _ref2$suppressRefErro = _ref2.suppressRefError,
            suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;

        var latestState = latest.current.state;
        setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);
        return _extends$2(_extends$2((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function(menuNode) {
            menuRef.current = menuNode;
        }), _extends2.id = elementIdsRef.current.menuId, _extends2.role = 'listbox', _extends2['aria-labelledby'] = elementIdsRef.current.labelId, _extends2.tabIndex = -1, _extends2), latestState.isOpen && latestState.highlightedIndex > -1 && {
            'aria-activedescendant': elementIdsRef.current.getItemId(latestState.highlightedIndex)
        }), {}, {
            onMouseLeave: callAllEventHandlers(onMouseLeave, function menuHandleMouseLeave() {
                dispatch({
                    type: MenuMouseLeave
                });
            }),
            onKeyDown: callAllEventHandlers(onKeyDown, function menuHandleKeyDown(event) {
                var key = normalizeArrowKey(event);

                if (key && menuKeyDownHandlers[key]) {
                    menuKeyDownHandlers[key](event);
                } else if (isAcceptedCharacterKey(key)) {
                    dispatch({
                        type: MenuKeyDownCharacter,
                        key: key,
                        getItemNodeFromIndex: getItemNodeFromIndex
                    });
                }
            }),
            onBlur: callAllEventHandlers(onBlur, function menuHandleBlur() {
                // if the blur was a result of selection, we don't trigger this action.
                if (shouldBlurRef.current === false) {
                    shouldBlurRef.current = true;
                    return;
                }

                var shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;
                /* istanbul ignore else */

                if (shouldBlur) {
                    dispatch({
                        type: MenuBlur
                    });
                }
            })
        }, rest);
    }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo]);
    var getToggleButtonProps = React.useCallback(function(_temp3, _temp4) {
        var _extends3;

        var _ref3 = _temp3 === void 0 ? {} : _temp3,
            onClick = _ref3.onClick,
            onKeyDown = _ref3.onKeyDown,
            _ref3$refKey = _ref3.refKey,
            refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
            ref = _ref3.ref,
            rest = _objectWithoutPropertiesLoose$1(_ref3, ["onClick", "onKeyDown", "refKey", "ref"]);

        var _ref4 = _temp4 === void 0 ? {} : _temp4,
            _ref4$suppressRefErro = _ref4.suppressRefError,
            suppressRefError = _ref4$suppressRefErro === void 0 ? false : _ref4$suppressRefErro;

        var toggleButtonHandleClick = function() {
            dispatch({
                type: ToggleButtonClick
            });
        };

        var toggleButtonHandleKeyDown = function(event) {
            var key = normalizeArrowKey(event);

            if (key && toggleButtonKeyDownHandlers[key]) {
                toggleButtonKeyDownHandlers[key](event);
            } else if (isAcceptedCharacterKey(key)) {
                dispatch({
                    type: ToggleButtonKeyDownCharacter,
                    key: key,
                    getItemNodeFromIndex: getItemNodeFromIndex
                });
            }
        };

        var toggleProps = _extends$2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(toggleButtonNode) {
            toggleButtonRef.current = toggleButtonNode;
        }), _extends3.id = elementIdsRef.current.toggleButtonId, _extends3['aria-haspopup'] = 'listbox', _extends3['aria-expanded'] = latest.current.state.isOpen, _extends3['aria-labelledby'] = elementIdsRef.current.labelId + " " + elementIdsRef.current.toggleButtonId, _extends3), rest);

        if (!rest.disabled) {
            toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
            toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
        }

        setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);
        return toggleProps;
    }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo]);
    var getItemProps = React.useCallback(function(_temp5) {
        var _extends4;

        var _ref5 = _temp5 === void 0 ? {} : _temp5,
            item = _ref5.item,
            index = _ref5.index,
            onMouseMove = _ref5.onMouseMove,
            onClick = _ref5.onClick,
            _ref5$refKey = _ref5.refKey,
            refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
            ref = _ref5.ref,
            rest = _objectWithoutPropertiesLoose$1(_ref5, ["item", "index", "onMouseMove", "onClick", "refKey", "ref"]);

        var _latest$current = latest.current,
            latestState = _latest$current.state,
            latestProps = _latest$current.props;

        var itemHandleMouseMove = function() {
            if (index === latestState.highlightedIndex) {
                return;
            }

            shouldScrollRef.current = false;
            dispatch({
                type: ItemMouseMove,
                index: index
            });
        };

        var itemHandleClick = function() {
            dispatch({
                type: ItemClick,
                index: index
            });
        };

        var itemIndex = getItemIndex(index, item, latestProps.items);

        if (itemIndex < 0) {
            throw new Error('Pass either item or item index in getItemProps!');
        }

        var itemProps = _extends$2((_extends4 = {
            role: 'option',
            'aria-selected': "" + (itemIndex === latestState.highlightedIndex),
            id: elementIdsRef.current.getItemId(itemIndex)
        }, _extends4[refKey] = handleRefs(ref, function(itemNode) {
            if (itemNode) {
                itemRefs.current[elementIdsRef.current.getItemId(itemIndex)] = itemNode;
            }
        }), _extends4), rest);

        if (!rest.disabled) {
            itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
            itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
        }

        return itemProps;
    }, [dispatch, latest]);
    return {
        // prop getters.
        getToggleButtonProps: getToggleButtonProps,
        getLabelProps: getLabelProps,
        getMenuProps: getMenuProps,
        getItemProps: getItemProps,
        // actions.
        toggleMenu: toggleMenu,
        openMenu: openMenu,
        closeMenu: closeMenu,
        setHighlightedIndex: setHighlightedIndex,
        selectItem: selectItem,
        reset: reset,
        setInputValue: setInputValue,
        // state.
        highlightedIndex: highlightedIndex,
        isOpen: isOpen,
        selectedItem: selectedItem,
        inputValue: inputValue
    };
}

var InputKeyDownArrowDown = process.env.NODE_ENV !== "production" ? '__input_keydown_arrow_down__' : 0;
var InputKeyDownArrowUp = process.env.NODE_ENV !== "production" ? '__input_keydown_arrow_up__' : 1;
var InputKeyDownEscape = process.env.NODE_ENV !== "production" ? '__input_keydown_escape__' : 2;
var InputKeyDownHome = process.env.NODE_ENV !== "production" ? '__input_keydown_home__' : 3;
var InputKeyDownEnd = process.env.NODE_ENV !== "production" ? '__input_keydown_end__' : 4;
var InputKeyDownEnter = process.env.NODE_ENV !== "production" ? '__input_keydown_enter__' : 5;
var InputChange = process.env.NODE_ENV !== "production" ? '__input_change__' : 6;
var InputBlur = process.env.NODE_ENV !== "production" ? '__input_blur__' : 7;
var MenuMouseLeave$1 = process.env.NODE_ENV !== "production" ? '__menu_mouse_leave__' : 8;
var ItemMouseMove$1 = process.env.NODE_ENV !== "production" ? '__item_mouse_move__' : 9;
var ItemClick$1 = process.env.NODE_ENV !== "production" ? '__item_click__' : 10;
var ToggleButtonClick$1 = process.env.NODE_ENV !== "production" ? '__togglebutton_click__' : 11;
var FunctionToggleMenu$1 = process.env.NODE_ENV !== "production" ? '__function_toggle_menu__' : 12;
var FunctionOpenMenu$1 = process.env.NODE_ENV !== "production" ? '__function_open_menu__' : 13;
var FunctionCloseMenu$1 = process.env.NODE_ENV !== "production" ? '__function_close_menu__' : 14;
var FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== "production" ? '__function_set_highlighted_index__' : 15;
var FunctionSelectItem$1 = process.env.NODE_ENV !== "production" ? '__function_select_item__' : 16;
var FunctionSetInputValue$1 = process.env.NODE_ENV !== "production" ? '__function_set_input_value__' : 17;
var FunctionReset$1 = process.env.NODE_ENV !== "production" ? '__function_reset__' : 18;
var ControlledPropUpdatedSelectedItem = process.env.NODE_ENV !== "production" ? '__controlled_prop_updated_selected_item__' : 19;

var stateChangeTypes$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    InputKeyDownArrowDown: InputKeyDownArrowDown,
    InputKeyDownArrowUp: InputKeyDownArrowUp,
    InputKeyDownEscape: InputKeyDownEscape,
    InputKeyDownHome: InputKeyDownHome,
    InputKeyDownEnd: InputKeyDownEnd,
    InputKeyDownEnter: InputKeyDownEnter,
    InputChange: InputChange,
    InputBlur: InputBlur,
    MenuMouseLeave: MenuMouseLeave$1,
    ItemMouseMove: ItemMouseMove$1,
    ItemClick: ItemClick$1,
    ToggleButtonClick: ToggleButtonClick$1,
    FunctionToggleMenu: FunctionToggleMenu$1,
    FunctionOpenMenu: FunctionOpenMenu$1,
    FunctionCloseMenu: FunctionCloseMenu$1,
    FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
    FunctionSelectItem: FunctionSelectItem$1,
    FunctionSetInputValue: FunctionSetInputValue$1,
    FunctionReset: FunctionReset$1,
    ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem
});

function getElementIds$1(_ref) {
    var id = _ref.id,
        inputId = _ref.inputId,
        rest = _objectWithoutPropertiesLoose$1(_ref, ["id", "inputId"]);

    var uniqueId = id === undefined ? "downshift-" + generateId() : id;
    return _extends$2({
        inputId: inputId || uniqueId + "-input"
    }, getElementIds(_extends$2({
        id: id
    }, rest)));
}

function getInitialState$1(props) {
    var initialState = getInitialState(props);
    var selectedItem = initialState.selectedItem;
    var inputValue = initialState.inputValue;

    if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {
        inputValue = props.itemToString(selectedItem);
    }

    return _extends$2(_extends$2({}, initialState), {}, {
        inputValue: inputValue
    });
}
var propTypes$1 = {
    items: PropTypes.array.isRequired,
    itemToString: PropTypes.func,
    getA11yStatusMessage: PropTypes.func,
    getA11ySelectionMessage: PropTypes.func,
    circularNavigation: PropTypes.bool,
    highlightedIndex: PropTypes.number,
    defaultHighlightedIndex: PropTypes.number,
    initialHighlightedIndex: PropTypes.number,
    isOpen: PropTypes.bool,
    defaultIsOpen: PropTypes.bool,
    initialIsOpen: PropTypes.bool,
    selectedItem: PropTypes.any,
    initialSelectedItem: PropTypes.any,
    defaultSelectedItem: PropTypes.any,
    inputValue: PropTypes.string,
    defaultInputValue: PropTypes.string,
    initialInputValue: PropTypes.string,
    id: PropTypes.string,
    labelId: PropTypes.string,
    menuId: PropTypes.string,
    getItemId: PropTypes.func,
    inputId: PropTypes.string,
    toggleButtonId: PropTypes.string,
    stateReducer: PropTypes.func,
    onSelectedItemChange: PropTypes.func,
    onHighlightedIndexChange: PropTypes.func,
    onStateChange: PropTypes.func,
    onIsOpenChange: PropTypes.func,
    onInputValueChange: PropTypes.func,
    environment: PropTypes.shape({
        addEventListener: PropTypes.func,
        removeEventListener: PropTypes.func,
        document: PropTypes.shape({
            getElementById: PropTypes.func,
            activeElement: PropTypes.any,
            body: PropTypes.any
        })
    })
};
/**
 * The useCombobox version of useControlledReducer, which also
 * checks if the controlled prop selectedItem changed between
 * renders. If so, it will also update inputValue with its
 * string equivalent. It uses the common useEnhancedReducer to
 * compute the rest of the state.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */

function useControlledReducer$1(reducer, initialState, props) {
    var previousSelectedItemRef = React.useRef();

    var _useEnhancedReducer = useEnhancedReducer(reducer, initialState, props),
        state = _useEnhancedReducer[0],
        dispatch = _useEnhancedReducer[1]; // ToDo: if needed, make same approach as selectedItemChanged from Downshift.


    if (isControlledProp(props, 'selectedItem')) {
        if (previousSelectedItemRef.current !== props.selectedItem) {
            dispatch({
                type: ControlledPropUpdatedSelectedItem,
                inputValue: props.itemToString(props.selectedItem)
            });
        }

        previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
    }

    return [getState(state, props), dispatch];
}
var defaultProps$2 = _extends$2(_extends$2({}, defaultProps), {}, {
    getA11yStatusMessage: getA11yStatusMessage,
    circularNavigation: true
});

/* eslint-disable complexity */

function downshiftUseComboboxReducer(state, action) {
    var type = action.type,
        props = action.props,
        shiftKey = action.shiftKey;
    var changes;

    switch (type) {
        case ItemMouseMove$1:
            changes = {
                highlightedIndex: action.index
            };
            break;

        case ItemClick$1:
            changes = {
                isOpen: getDefaultValue(props, 'isOpen'),
                highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
                selectedItem: props.items[action.index],
                inputValue: props.itemToString(props.items[action.index])
            };
            break;

        case InputKeyDownArrowDown:
            if (state.isOpen) {
                changes = {
                    highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
                };
            } else {
                changes = {
                    highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
                    isOpen: true
                };
            }

            break;

        case InputKeyDownArrowUp:
            if (state.isOpen) {
                changes = {
                    highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
                };
            } else {
                changes = {
                    highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
                    isOpen: true
                };
            }

            break;

        case InputKeyDownEnter:
            changes = _extends$2({}, state.highlightedIndex >= 0 && {
                selectedItem: props.items[state.highlightedIndex],
                isOpen: getDefaultValue(props, 'isOpen'),
                highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
                inputValue: props.itemToString(props.items[state.highlightedIndex])
            });
            break;

        case InputKeyDownEscape:
            changes = {
                isOpen: false,
                selectedItem: null,
                highlightedIndex: -1,
                inputValue: ''
            };
            break;

        case InputKeyDownHome:
            changes = {
                highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
            };
            break;

        case InputKeyDownEnd:
            changes = {
                highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
            };
            break;

        case InputBlur:
            changes = _extends$2({
                isOpen: false
            }, state.highlightedIndex >= 0 && {
                selectedItem: props.items[state.highlightedIndex],
                inputValue: props.itemToString(props.items[state.highlightedIndex]),
                highlightedIndex: -1
            });
            break;

        case InputChange:
            changes = {
                isOpen: true,
                highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
                inputValue: action.inputValue
            };
            break;

        case MenuMouseLeave$1:
            changes = {
                highlightedIndex: -1
            };
            break;

        case ToggleButtonClick$1:
        case FunctionToggleMenu$1:
            changes = {
                isOpen: !state.isOpen,
                highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
            };
            break;

        case FunctionOpenMenu$1:
            changes = {
                isOpen: true,
                highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
            };
            break;

        case FunctionCloseMenu$1:
            changes = {
                isOpen: false
            };
            break;

        case FunctionSetHighlightedIndex$1:
            changes = {
                highlightedIndex: action.highlightedIndex
            };
            break;

        case FunctionSelectItem$1:
            changes = {
                selectedItem: action.selectedItem,
                inputValue: props.itemToString(action.selectedItem)
            };
            break;

        case ControlledPropUpdatedSelectedItem:
        case FunctionSetInputValue$1:
            changes = {
                inputValue: action.inputValue
            };
            break;

        case FunctionReset$1:
            changes = {
                highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
                isOpen: getDefaultValue(props, 'isOpen'),
                selectedItem: getDefaultValue(props, 'selectedItem'),
                inputValue: getDefaultValue(props, 'inputValue')
            };
            break;

        default:
            throw new Error('Reducer called without proper action type.');
    }

    return _extends$2(_extends$2({}, state), changes);
}
/* eslint-enable complexity */

var validatePropTypes$1 = process.env.NODE_ENV === 'production' ?
    /* istanbul ignore next */
    null : getPropTypesValidator(useCombobox, propTypes$1);
useCombobox.stateChangeTypes = stateChangeTypes$2;

function useCombobox(userProps) {
    if (userProps === void 0) {
        userProps = {};
    }

    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
        validatePropTypes$1(userProps);
    } // Props defaults and destructuring.


    var props = _extends$2(_extends$2({}, defaultProps$2), userProps);

    var initialIsOpen = props.initialIsOpen,
        defaultIsOpen = props.defaultIsOpen,
        items = props.items,
        scrollIntoView = props.scrollIntoView,
        environment = props.environment,
        getA11yStatusMessage = props.getA11yStatusMessage,
        getA11ySelectionMessage = props.getA11ySelectionMessage,
        itemToString = props.itemToString; // Initial state depending on controlled props.

    var initialState = getInitialState$1(props);

    var _useControlledReducer = useControlledReducer$1(downshiftUseComboboxReducer, initialState, props),
        state = _useControlledReducer[0],
        dispatch = _useControlledReducer[1];

    var isOpen = state.isOpen,
        highlightedIndex = state.highlightedIndex,
        selectedItem = state.selectedItem,
        inputValue = state.inputValue; // Element refs.

    var menuRef = React.useRef(null);
    var itemRefs = React.useRef();
    var inputRef = React.useRef(null);
    var toggleButtonRef = React.useRef(null);
    var comboboxRef = React.useRef(null);
    itemRefs.current = {}; // used not to scroll on highlight by mouse.

    var shouldScrollRef = React.useRef(true);
    var isInitialMountRef = React.useRef(true); // prevent id re-generation between renders.

    var elementIdsRef = React.useRef(getElementIds$1(props)); // used to keep track of how many items we had on previous cycle.

    var previousResultCountRef = React.useRef(); // used for checking when props are moving from controlled to uncontrolled.

    var prevPropsRef = React.useRef(props); // used to store information about getter props being called on render.
    // utility callback to get item element.

    var latest = useLatestRef({
        state: state,
        props: props
    });

    var getItemNodeFromIndex = function(index) {
        return itemRefs.current[elementIdsRef.current.getItemId(index)];
    }; // Effects.
    // Sets a11y status message on changes in state.


    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        var previousResultCount = previousResultCountRef.current;
        updateA11yStatus(function() {
            return getA11yStatusMessage({
                isOpen: isOpen,
                highlightedIndex: highlightedIndex,
                selectedItem: selectedItem,
                inputValue: inputValue,
                highlightedItem: items[highlightedIndex],
                resultCount: items.length,
                itemToString: itemToString,
                previousResultCount: previousResultCount
            });
        }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen, highlightedIndex, inputValue, items]); // Sets a11y status message on changes in selectedItem.

    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        var previousResultCount = previousResultCountRef.current;
        updateA11yStatus(function() {
            return getA11ySelectionMessage({
                isOpen: isOpen,
                highlightedIndex: highlightedIndex,
                selectedItem: selectedItem,
                inputValue: inputValue,
                highlightedItem: items[highlightedIndex],
                resultCount: items.length,
                itemToString: itemToString,
                previousResultCount: previousResultCount
            });
        }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectedItem]); // Scroll on highlighted item if change comes from keyboard.

    React.useEffect(function() {
        if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
            return;
        }

        if (shouldScrollRef.current === false) {
            shouldScrollRef.current = true;
        } else {
            scrollIntoView(getItemNodeFromIndex(highlightedIndex), menuRef.current);
        } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [highlightedIndex]); // Controls the focus on the menu or the toggle button.

    React.useEffect(function() {
        // Don't focus menu on first render.
        if (isInitialMountRef.current) {
            // Unless it was initialised as open.
            if (initialIsOpen || defaultIsOpen || isOpen) {
                if (inputRef.current) {
                    inputRef.current.focus();
                }
            }
        } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [isOpen]);
    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        previousResultCountRef.current = items.length;
    });
    React.useEffect(function() {
        if (isInitialMountRef.current) {
            return;
        }

        validateControlledUnchanged(state, prevPropsRef.current, props);
        prevPropsRef.current = props;
    }, [state, props]); // Add mouse/touch events to document.

    var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, function() {
        dispatch({
            type: InputBlur
        });
    });
    var setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.

    React.useEffect(function() {
        isInitialMountRef.current = false;
    }, []);
    /* Event handler functions */

    var inputKeyDownHandlers = React.useMemo(function() {
        return {
            ArrowDown: function ArrowDown(event) {
                event.preventDefault();
                dispatch({
                    type: InputKeyDownArrowDown,
                    shiftKey: event.shiftKey,
                    getItemNodeFromIndex: getItemNodeFromIndex
                });
            },
            ArrowUp: function ArrowUp(event) {
                event.preventDefault();
                dispatch({
                    type: InputKeyDownArrowUp,
                    shiftKey: event.shiftKey,
                    getItemNodeFromIndex: getItemNodeFromIndex
                });
            },
            Home: function Home(event) {
                event.preventDefault();
                dispatch({
                    type: InputKeyDownHome,
                    getItemNodeFromIndex: getItemNodeFromIndex
                });
            },
            End: function End(event) {
                event.preventDefault();
                dispatch({
                    type: InputKeyDownEnd,
                    getItemNodeFromIndex: getItemNodeFromIndex
                });
            },
            Escape: function Escape() {
                dispatch({
                    type: InputKeyDownEscape
                });
            },
            Enter: function Enter(event) {
                // if IME composing, wait for next Enter keydown event.
                if (event.which === 229) {
                    return;
                }

                var latestState = latest.current.state;

                if (latestState.isOpen && latestState.highlightedIndex > -1) {
                    event.preventDefault();
                    dispatch({
                        type: InputKeyDownEnter,
                        getItemNodeFromIndex: getItemNodeFromIndex
                    });
                }
            }
        };
    }, [dispatch, latest]); // Getter props.

    var getLabelProps = React.useCallback(function(labelProps) {
        return _extends$2({
            id: elementIdsRef.current.labelId,
            htmlFor: elementIdsRef.current.inputId
        }, labelProps);
    }, []);
    var getMenuProps = React.useCallback(function(_temp, _temp2) {
        var _extends2;

        var _ref = _temp === void 0 ? {} : _temp,
            onMouseLeave = _ref.onMouseLeave,
            _ref$refKey = _ref.refKey,
            refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
            ref = _ref.ref,
            rest = _objectWithoutPropertiesLoose$1(_ref, ["onMouseLeave", "refKey", "ref"]);

        var _ref2 = _temp2 === void 0 ? {} : _temp2,
            _ref2$suppressRefErro = _ref2.suppressRefError,
            suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;

        setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);
        return _extends$2((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function(menuNode) {
            menuRef.current = menuNode;
        }), _extends2.id = elementIdsRef.current.menuId, _extends2.role = 'listbox', _extends2['aria-labelledby'] = elementIdsRef.current.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
            dispatch({
                type: MenuMouseLeave$1
            });
        }), _extends2), rest);
    }, [dispatch, setGetterPropCallInfo]);
    var getItemProps = React.useCallback(function(_temp3) {
        var _extends3, _ref4;

        var _ref3 = _temp3 === void 0 ? {} : _temp3,
            item = _ref3.item,
            index = _ref3.index,
            _ref3$refKey = _ref3.refKey,
            refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
            ref = _ref3.ref,
            onMouseMove = _ref3.onMouseMove,
            onClick = _ref3.onClick,
            onPress = _ref3.onPress,
            rest = _objectWithoutPropertiesLoose$1(_ref3, ["item", "index", "refKey", "ref", "onMouseMove", "onClick", "onPress"]);

        var _latest$current = latest.current,
            latestProps = _latest$current.props,
            latestState = _latest$current.state;
        var itemIndex = getItemIndex(index, item, latestProps.items);

        if (itemIndex < 0) {
            throw new Error('Pass either item or item index in getItemProps!');
        }

        var onSelectKey = 'onClick';
        var customClickHandler = onClick;
        return _extends$2(_extends$2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(itemNode) {
            if (itemNode) {
                itemRefs.current[elementIdsRef.current.getItemId(itemIndex)] = itemNode;
            }
        }), _extends3.role = 'option', _extends3['aria-selected'] = "" + (itemIndex === latestState.highlightedIndex), _extends3.id = elementIdsRef.current.getItemId(itemIndex), _extends3), !rest.disabled && (_ref4 = {
            onMouseMove: callAllEventHandlers(onMouseMove, function itemHandleMouseMove() {
                if (index === latestState.highlightedIndex) {
                    return;
                }

                shouldScrollRef.current = false;
                dispatch({
                    type: ItemMouseMove$1,
                    index: index
                });
            })
        }, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, function itemHandleClick() {
            dispatch({
                type: ItemClick$1,
                index: index
            });
        }), _ref4)), rest);
    }, [dispatch, latest]);
    var getToggleButtonProps = React.useCallback(function(_temp4) {
        var _extends4;

        var _ref5 = _temp4 === void 0 ? {} : _temp4,
            onClick = _ref5.onClick,
            onPress = _ref5.onPress,
            _ref5$refKey = _ref5.refKey,
            refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
            ref = _ref5.ref,
            rest = _objectWithoutPropertiesLoose$1(_ref5, ["onClick", "onPress", "refKey", "ref"]);

        var toggleButtonHandleClick = function() {
            dispatch({
                type: ToggleButtonClick$1
            });

            if (!latest.current.state.isOpen && inputRef.current) {
                inputRef.current.focus();
            }
        };

        return _extends$2(_extends$2((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(toggleButtonNode) {
            toggleButtonRef.current = toggleButtonNode;
        }), _extends4.id = elementIdsRef.current.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends$2({}, {
            onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
        })), rest);
    }, [dispatch, latest]);
    var getInputProps = React.useCallback(function(_temp5, _temp6) {
        var _extends5;

        var _ref6 = _temp5 === void 0 ? {} : _temp5,
            onKeyDown = _ref6.onKeyDown,
            onChange = _ref6.onChange,
            onInput = _ref6.onInput,
            onBlur = _ref6.onBlur,
            onChangeText = _ref6.onChangeText,
            _ref6$refKey = _ref6.refKey,
            refKey = _ref6$refKey === void 0 ? 'ref' : _ref6$refKey,
            ref = _ref6.ref,
            rest = _objectWithoutPropertiesLoose$1(_ref6, ["onKeyDown", "onChange", "onInput", "onBlur", "onChangeText", "refKey", "ref"]);

        var _ref7 = _temp6 === void 0 ? {} : _temp6,
            _ref7$suppressRefErro = _ref7.suppressRefError,
            suppressRefError = _ref7$suppressRefErro === void 0 ? false : _ref7$suppressRefErro;

        setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);
        var latestState = latest.current.state;

        var inputHandleKeyDown = function(event) {
            var key = normalizeArrowKey(event);

            if (key && inputKeyDownHandlers[key]) {
                inputKeyDownHandlers[key](event);
            }
        };

        var inputHandleChange = function(event) {
            dispatch({
                type: InputChange,
                inputValue: event.target.value
            });
        };

        var inputHandleBlur = function() {
            /* istanbul ignore else */
            if (!mouseAndTouchTrackersRef.current.isMouseDown) {
                dispatch({
                    type: InputBlur
                });
            }
        };
        /* istanbul ignore next (preact) */


        var onChangeKey = 'onChange';
        var eventHandlers = {};

        if (!rest.disabled) {
            var _eventHandlers;

            eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers);
        }
        /* istanbul ignore if (react-native) */


        return _extends$2(_extends$2(_extends$2((_extends5 = {}, _extends5[refKey] = handleRefs(ref, function(inputNode) {
            inputRef.current = inputNode;
        }), _extends5.id = elementIdsRef.current.inputId, _extends5['aria-autocomplete'] = 'list', _extends5['aria-controls'] = elementIdsRef.current.menuId, _extends5), latestState.isOpen && latestState.highlightedIndex > -1 && {
            'aria-activedescendant': elementIdsRef.current.getItemId(latestState.highlightedIndex)
        }), {}, {
            'aria-labelledby': elementIdsRef.current.labelId,
            // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
            // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
            autoComplete: 'off',
            value: latestState.inputValue
        }, eventHandlers), rest);
    }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo]);
    var getComboboxProps = React.useCallback(function(_temp7, _temp8) {
        var _extends6;

        var _ref8 = _temp7 === void 0 ? {} : _temp7,
            _ref8$refKey = _ref8.refKey,
            refKey = _ref8$refKey === void 0 ? 'ref' : _ref8$refKey,
            ref = _ref8.ref,
            rest = _objectWithoutPropertiesLoose$1(_ref8, ["refKey", "ref"]);

        var _ref9 = _temp8 === void 0 ? {} : _temp8,
            _ref9$suppressRefErro = _ref9.suppressRefError,
            suppressRefError = _ref9$suppressRefErro === void 0 ? false : _ref9$suppressRefErro;

        setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);
        return _extends$2((_extends6 = {}, _extends6[refKey] = handleRefs(ref, function(comboboxNode) {
            comboboxRef.current = comboboxNode;
        }), _extends6.role = 'combobox', _extends6['aria-haspopup'] = 'listbox', _extends6['aria-owns'] = elementIdsRef.current.menuId, _extends6['aria-expanded'] = latest.current.state.isOpen, _extends6), rest);
    }, [latest, setGetterPropCallInfo]); // returns

    var toggleMenu = React.useCallback(function() {
        dispatch({
            type: FunctionToggleMenu$1
        });
    }, [dispatch]);
    var closeMenu = React.useCallback(function() {
        dispatch({
            type: FunctionCloseMenu$1
        });
    }, [dispatch]);
    var openMenu = React.useCallback(function() {
        dispatch({
            type: FunctionOpenMenu$1
        });
    }, [dispatch]);
    var setHighlightedIndex = React.useCallback(function(newHighlightedIndex) {
        dispatch({
            type: FunctionSetHighlightedIndex$1,
            highlightedIndex: newHighlightedIndex
        });
    }, [dispatch]);
    var selectItem = React.useCallback(function(newSelectedItem) {
        dispatch({
            type: FunctionSelectItem$1,
            selectedItem: newSelectedItem
        });
    }, [dispatch]);
    var setInputValue = React.useCallback(function(newInputValue) {
        dispatch({
            type: FunctionSetInputValue$1,
            inputValue: newInputValue
        });
    }, [dispatch]);
    var reset = React.useCallback(function() {
        dispatch({
            type: FunctionReset$1
        });
    }, [dispatch]);
    return {
        // prop getters.
        getItemProps: getItemProps,
        getLabelProps: getLabelProps,
        getMenuProps: getMenuProps,
        getInputProps: getInputProps,
        getComboboxProps: getComboboxProps,
        getToggleButtonProps: getToggleButtonProps,
        // actions.
        toggleMenu: toggleMenu,
        openMenu: openMenu,
        closeMenu: closeMenu,
        setHighlightedIndex: setHighlightedIndex,
        setInputValue: setInputValue,
        selectItem: selectItem,
        reset: reset,
        // state.
        highlightedIndex: highlightedIndex,
        isOpen: isOpen,
        selectedItem: selectedItem,
        inputValue: inputValue
    };
}

var propTypes$2 = {
    selectedItems: PropTypes.array,
    initialSelectedItems: PropTypes.array,
    defaultSelectedItems: PropTypes.array,
    itemToString: PropTypes.func,
    getA11yRemovalMessage: PropTypes.func,
    stateReducer: PropTypes.func,
    activeIndex: PropTypes.number,
    initialActiveIndex: PropTypes.number,
    defaultActiveIndex: PropTypes.number,
    onActiveIndexChange: PropTypes.func,
    onSelectedItemsChange: PropTypes.func,
    keyNavigationNext: PropTypes.string,
    keyNavigationPrevious: PropTypes.string,
    environment: PropTypes.shape({
        addEventListener: PropTypes.func,
        removeEventListener: PropTypes.func,
        document: PropTypes.shape({
            getElementById: PropTypes.func,
            activeElement: PropTypes.any,
            body: PropTypes.any
        })
    })
};

var SelectedItemClick = process.env.NODE_ENV !== "production" ? '__selected_item_click__' : 0;
var SelectedItemKeyDownDelete = process.env.NODE_ENV !== "production" ? '__selected_item_keydown_delete__' : 1;
var SelectedItemKeyDownBackspace = process.env.NODE_ENV !== "production" ? '__selected_item_keydown_backspace__' : 2;
var SelectedItemKeyDownNavigationNext = process.env.NODE_ENV !== "production" ? '__selected_item_keydown_navigation_next__' : 3;
var SelectedItemKeyDownNavigationPrevious = process.env.NODE_ENV !== "production" ? '__selected_item_keydown_navigation_previous__' : 4;
var DropdownKeyDownNavigationPrevious = process.env.NODE_ENV !== "production" ? '__dropdown_keydown_navigation_previous__' : 5;
var DropdownKeyDownBackspace = process.env.NODE_ENV !== "production" ? '__dropdown_keydown_backspace__' : 6;
var DropdownClick = process.env.NODE_ENV !== "production" ? '__dropdown_click__' : 7;
var FunctionAddSelectedItem = process.env.NODE_ENV !== "production" ? '__function_add_selected_item__' : 8;
var FunctionRemoveSelectedItem = process.env.NODE_ENV !== "production" ? '__function_remove_selected_item__' : 9;
var FunctionSetSelectedItems = process.env.NODE_ENV !== "production" ? '__function_set_selected_items__' : 10;
var FunctionSetActiveIndex = process.env.NODE_ENV !== "production" ? '__function_set_active_index__' : 11;
var FunctionReset$2 = process.env.NODE_ENV !== "production" ? '__function_reset__' : 12;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({
                __proto__: []
            }
            instanceof Array && function(d, b) {
                d.__proto__ = b;
            }) ||
        function(d, b) {
            for (var p in b)
                if (b.hasOwnProperty(p)) d[p] = b[p];
        };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);

    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var SelectOnKeyPressContainer =
    /** @class */
    function(_super) {
        __extends(SelectOnKeyPressContainer, _super);

        function SelectOnKeyPressContainer(props) {
            var _this = _super.call(this, props) || this;

            _this.onKeyDown = _this.onKeyDown.bind(_this);
            document.addEventListener("keydown", _this.onKeyDown, true);
            return _this;
        }

        SelectOnKeyPressContainer.prototype.componentWillUnmount = function() {
            document.removeEventListener("keydown", this.onKeyDown, false);
        };

        SelectOnKeyPressContainer.prototype.onKeyDown = function(event) {
            var _a = this.props,
                options = _a.options,
                isOpen = _a.isOpen,
                highlightedIndex = _a.highlightedIndex,
                setHighlightedIndex = _a.setHighlightedIndex;

            if (isOpen) {
                var keyDownValue_1 = String(event.key);
                var idx = 0;
                idx = options.findIndex(function(option) {
                    var optionValue = String(option.value).trim();
                    var firstCharacter = optionValue.charAt(0).toLowerCase();
                    return firstCharacter === keyDownValue_1;
                });

                if (idx >= 0 && idx !== highlightedIndex) {
                    setHighlightedIndex(idx);
                }
            }
        };

        SelectOnKeyPressContainer.prototype.render = function() {
            var children = this.props.children;
            return children;
        };

        return SelectOnKeyPressContainer;
    }(React__default.Component);

var PREFIX$o = "vds-select";
/** Select is a control for selecting a single choice from a list of four or more options. */

var Select = function(_a) {
    // Null/undefined checks are necessary to catch all cases.
    // We assume the default prop value is applied when validation
    // is present, but the variant property is undefined.
    var id = _a.id,
        label = _a.label,
        options = _a.options,
        defaultValue = _a.defaultValue,
        disabled = _a.disabled,
        hiddenLabel = _a.hiddenLabel,
        onBlur = _a.onBlur,
        onChange = _a.onChange,
        onFocus = _a.onFocus,
        _b = _a.optionalLabel,
        optionalLabel = _b === void 0 ? "Optional" : _b,
        required = _a.required,
        testID = _a.testID,
        validation = _a.validation,
        value = _a.value;
    var isError = validation && validation.props.variant === undefined || validation && validation.props.variant === "error";
    var className = classnames(PREFIX$o, isError && PREFIX$o + "--error", !isError && validation && PREFIX$o + "--" + validation.props.variant);
    var labelClassName = classnames(PREFIX$o + "__label", hiddenLabel && "vds-visually-hidden");
    return /*#__PURE__*/ React__default.createElement(Downshift, {
        itemToString: stringifyItem,
        onChange: onChange
    }, function(_a) {
        var getItemProps = _a.getItemProps,
            getLabelProps = _a.getLabelProps,
            getMenuProps = _a.getMenuProps,
            getToggleButtonProps = _a.getToggleButtonProps,
            highlightedIndex = _a.highlightedIndex,
            selectedItem = _a.selectedItem,
            setHighlightedIndex = _a.setHighlightedIndex,
            isOpen = _a.isOpen;
        return /*#__PURE__*/ React__default.createElement("div", {
            className: classnames(className, !isOpen && PREFIX$o + "--hidden"),
            "aria-invalid": isError,
            role: undefined
        }, /*#__PURE__*/ React__default.createElement(SelectOnKeyPressContainer, {
            options: options,
            isOpen: isOpen,
            highlightedIndex: highlightedIndex,
            setHighlightedIndex: setHighlightedIndex
        }, /*#__PURE__*/ React__default.createElement("label", getLabelProps({
            className: labelClassName,
            htmlFor: id
        }), label, !required && /*#__PURE__*/ React__default.createElement("span", {
            className: PREFIX$o + "__optional"
        }, "(" + optionalLabel + ")")), /*#__PURE__*/ React__default.createElement("div", {
            className: PREFIX$o + "__input-container"
        }, /*#__PURE__*/ React__default.createElement("button", _extends({
            "data-testid": testID
        }, getToggleButtonProps({
            className: PREFIX$o + "__toggle",
            disabled: disabled,
            id: id,
            onBlur: onBlur,
            onFocus: onFocus
        })), value || getItemLabel(selectedItem) || defaultValue), IconArrow, /*#__PURE__*/ React__default.createElement("ul", getMenuProps({
            className: PREFIX$o + "__options"
        }), options.map(function(item, index) {
            return /*#__PURE__*/ React__default.createElement("li", _extends({
                key: index
            }, getItemProps({
                className: getOptionClassName(index, highlightedIndex),
                item: item
            })), getItemLabel(item));
        }))), validation));
    });
};

var getOptionClassName = function(optionIndex, highlightedIndex) {
    var isSelected = optionIndex === highlightedIndex;
    return classnames(PREFIX$o + "__option", isSelected && PREFIX$o + "__option-selected");
};

var stringifyItem = function(item) {
    return item ? String(item.value) : "";
};

var getItemLabel = function(item) {
    if (item) {
        return item.label ? item.label : item.value;
    }

    return null;
};

var IconArrow = /*#__PURE__*/ React__default.createElement("i", {
    className: "vds-icon vds-icon--sm vds-icon--arrow",
    role: "img",
    "aria-hidden": "true"
}, /*#__PURE__*/ React__default.createElement("svg", {
    viewBox: "0 0 32 32"
}, /*#__PURE__*/ React__default.createElement("path", {
    d: "M8.16 11.411l7.13 10.175c.297.422.903.541 1.356.265a.947.947 0 0 0 .292-.276l6.91-10.175c.29-.425.153-.99-.304-1.259A1.033 1.033 0 0 0 23.02 10H8.98c-.542 0-.98.409-.98.912 0 .178.055.351.16.5z",
    fillRule: "evenodd"
})));

var PREFIX$p = "vds-spacing";
/** Space adjusts the areas below, between, or within components. */

var Space = function(_a) {
    var children = _a.children,
        type = _a.type,
        _b = _a.size,
        size = _b === void 0 ? "1x" : _b;
    var className = classnames(PREFIX$p, PREFIX$p + "--" + type + "-" + size);
    var Element = type === "inline" ? "span" : "div";
    return /*#__PURE__*/ React__default.createElement(Element, {
        className: className
    }, children);
};

var PREFIX$q = "vds-switch";
/**
 * Switch is a single control for quickly toggling between two mutally exclusive
 * states. They always have a default value, and trigger immediate results that
 * don't require submission.
 */

var Switch = function(_a) {
    var id = _a.id,
        label = _a.label,
        autoFocus = _a.autoFocus,
        checked = _a.checked,
        defaultChecked = _a.defaultChecked,
        disabled = _a.disabled,
        required = _a.required,
        hiddenLabel = _a.hiddenLabel,
        onChange = _a.onChange,
        testID = _a.testID;
    var className = classnames(PREFIX$q, hiddenLabel && PREFIX$q + "--hidden");
    var labelMarkup = hiddenLabel ? /*#__PURE__*/ React__default.createElement(VisuallyHidden, null, label) : label;
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className
    }, /*#__PURE__*/ React__default.createElement("input", {
        autoFocus: autoFocus,
        checked: checked,
        className: PREFIX$q + "__input",
        "data-testid": testID,
        defaultChecked: defaultChecked,
        disabled: disabled,
        id: id,
        required: required,
        role: "switch",
        onChange: onChange,
        type: "checkbox"
    }), /*#__PURE__*/ React__default.createElement("span", {
        className: PREFIX$q + "__toggle"
    }), /*#__PURE__*/ React__default.createElement("label", {
        className: PREFIX$q + "__label",
        htmlFor: id
    }, labelMarkup));
};

var PREFIX$r = "vds-text";
/** Text is used for paragraphs of body copy. */

var Text = function(_a) {
    var children = _a.children,
        _b = _a.align,
        align = _b === void 0 ? "left" : _b,
        _c = _a.color,
        color = _c === void 0 ? "black" : _c,
        full = _a.full,
        _d = _a.size,
        size = _d === void 0 ? "default" : _d,
        _e = _a.spacing,
        spacing = _e === void 0 ? "3x" : _e;
    var className = classnames(size === "default" ? PREFIX$r : PREFIX$r + "--" + size, align !== "left" && "vds-text-align--" + align, color !== "black" && "vds-color--" + color, "vds-spacing--stack-" + spacing, full && PREFIX$r + "--full");
    return /*#__PURE__*/ React__default.createElement("p", {
        className: className
    }, children);
};

var PREFIX$s = "vds-text-area";
/** TextArea is a control that accepts large amounts of multi-line text. */

var TextArea = function(_a) {
    // Null/undefined checks are necessary to catch all cases.
    // We assume the default prop value is applied when validation
    // is present, but the variant property is undefined.
    var id = _a.id,
        label = _a.label,
        autoComplete = _a.autoComplete,
        autoFocus = _a.autoFocus,
        defaultValue = _a.defaultValue,
        disabled = _a.disabled,
        hiddenLabel = _a.hiddenLabel,
        name = _a.name,
        onBlur = _a.onBlur,
        onChange = _a.onChange,
        onFocus = _a.onFocus,
        onKeyDown = _a.onKeyDown,
        _b = _a.optionalLabel,
        optionalLabel = _b === void 0 ? "Optional" : _b,
        placeholder = _a.placeholder,
        readOnly = _a.readOnly,
        required = _a.required,
        _c = _a.rows,
        rows = _c === void 0 ? 4 : _c,
        testID = _a.testID,
        validation = _a.validation,
        value = _a.value;
    var isError = validation && validation.props.variant === undefined || validation && validation.props.variant === "error";
    var className = classnames(PREFIX$s, isError && PREFIX$s + "--error", !isError && validation && PREFIX$s + "--" + validation.props.variant);
    var labelClassName = classnames(PREFIX$s + "__label", hiddenLabel && "vds-visually-hidden");
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className
    }, /*#__PURE__*/ React__default.createElement("label", {
        className: labelClassName,
        htmlFor: id
    }, label, !required && /*#__PURE__*/ React__default.createElement("span", {
        className: PREFIX$s + "__optional"
    }, "(" + optionalLabel + ")")), /*#__PURE__*/ React__default.createElement("textarea", {
        autoComplete: autoComplete,
        autoFocus: autoFocus,
        "aria-invalid": isError,
        className: PREFIX$s + "__input",
        "data-testid": testID,
        defaultValue: defaultValue,
        disabled: disabled,
        id: id,
        name: name,
        onBlur: onBlur,
        onChange: onChange,
        onFocus: onFocus,
        onKeyDown: onKeyDown,
        placeholder: placeholder,
        readOnly: readOnly,
        required: required,
        rows: rows,
        value: value
    }), validation);
};

var PREFIX$t = "vds-text-input";
/** TextInput is a control for entering text. */

var TextInput = function(_a) {
    // Null/undefined checks are necessary to catch all cases.
    // We assume the default prop value is applied when validation
    // is present, but the variant property is undefined.
    var id = _a.id,
        label = _a.label,
        autoFocus = _a.autoFocus,
        autoComplete = _a.autoComplete,
        defaultValue = _a.defaultValue,
        disabled = _a.disabled,
        hiddenLabel = _a.hiddenLabel,
        max = _a.max,
        min = _a.min,
        name = _a.name,
        onBlur = _a.onBlur,
        onChange = _a.onChange,
        onFocus = _a.onFocus,
        onKeyDown = _a.onKeyDown,
        _b = _a.optionalLabel,
        optionalLabel = _b === void 0 ? "Optional" : _b,
        pattern = _a.pattern,
        placeholder = _a.placeholder,
        readOnly = _a.readOnly,
        required = _a.required,
        testID = _a.testID,
        _c = _a.type,
        type = _c === void 0 ? "text" : _c,
        validation = _a.validation,
        value = _a.value,
        step = _a.step;
    var isError = validation && validation.props.variant === undefined || validation && validation.props.variant === "error";
    var className = classnames(PREFIX$t, isError && PREFIX$t + "--error", !isError && validation && PREFIX$t + "--" + validation.props.variant);
    var labelClassName = classnames(PREFIX$t + "__label", hiddenLabel && "vds-visually-hidden");
    return /*#__PURE__*/ React__default.createElement("div", {
        className: className
    }, /*#__PURE__*/ React__default.createElement("label", {
        className: labelClassName,
        htmlFor: id
    }, label, !required && /*#__PURE__*/ React__default.createElement("span", {
        className: PREFIX$t + "__optional"
    }, "(" + optionalLabel + ")")), /*#__PURE__*/ React__default.createElement("input", {
        autoFocus: autoFocus,
        autoComplete: autoComplete,
        "aria-invalid": isError,
        className: PREFIX$t + "__input",
        "data-testid": testID,
        defaultValue: defaultValue,
        disabled: disabled,
        id: id,
        max: max,
        min: min,
        name: name,
        onBlur: onBlur,
        onChange: onChange,
        onFocus: onFocus,
        onKeyDown: onKeyDown,
        pattern: pattern,
        placeholder: placeholder,
        readOnly: readOnly,
        required: required,
        step: step,
        type: type,
        value: value
    }), validation);
};

var generateId$1 = function() {
    var chars = 'acdefhiklmnoqrstuvwxyz0123456789'.split('');
    var result = '';

    for (var i = 0; i < 6; i++) {
        var x = Math.floor(Math.random() * chars.length);
        result += chars[x];
    }

    return result;
};

var PREFIX$u = "vds-tooltip";
var TOOLTIP_ID = PREFIX$u + "_" + generateId$1();
/**
 * Tooltip is a floating, non-actionable label used to explain a user interface
 * element or feature.
 */

var Tooltip = function(_a) {
    var content = _a.content,
        trigger = _a.trigger,
        _b = _a.direction,
        direction = _b === void 0 ? "bottom" : _b,
        _c = _a.inverse,
        inverse = _c === void 0 ? false : _c,
        _d = _a.open,
        controlledOpen = _d === void 0 ? false : _d; // Setup open state

    var _e = React.useState(false),
        uncontrolledOpen = _e[0],
        setOpen = _e[1];

    var open = controlledOpen || uncontrolledOpen; // Setup event listeners

    var handleOpen = React.useCallback(function() {
        return setOpen(true);
    }, [setOpen]);
    var handleClose = React.useCallback(function() {
        return setOpen(false);
    }, [setOpen]);
    var eventProps = React.useMemo(function() {
        return {
            onBlur: handleClose,
            onFocus: handleOpen,
            onMouseEnter: handleOpen,
            onMouseLeave: handleClose
        };
    }, [handleClose, handleOpen]); // Setup classnames

    var className = classnames(PREFIX$u, inverse && PREFIX$u + "--inverse");
    var arrowClassName = classnames("vds-tail", inverse && "vds-tail--inverse");
    return /*#__PURE__*/ React__default.createElement(Manager, null, /*#__PURE__*/ React__default.createElement(Reference, null, function(_a) {
        var ref = _a.ref;
        return /*#__PURE__*/ React__default.createElement("span", _extends({
            "aria-describedby": TOOLTIP_ID,
            ref: ref
        }, eventProps), trigger);
    }), /*#__PURE__*/ React__default.createElement("div", {
        "data-testid": PREFIX$u + "__wrapper",
        className: PREFIX$u + "__wrapper",
        "data-open": open
    }, /*#__PURE__*/ React__default.createElement(Popper$1, {
        placement: useDirectionToPopperPlacement(direction)
    }, function(_a) {
        var ref = _a.ref,
            placement = _a.placement,
            style = _a.style,
            arrowProps = _a.arrowProps;
        return /*#__PURE__*/ React__default.createElement("span", _extends({
            className: className,
            "data-placement": placement,
            id: TOOLTIP_ID,
            ref: ref,
            role: "tooltip",
            style: style
        }, eventProps), /*#__PURE__*/ React__default.createElement("span", {
            className: arrowClassName,
            ref: arrowProps.ref,
            style: arrowProps.style
        }), content);
    })));
};

var PREFIX$v = "vds-tag";
/** Tags are used to show at-a-glance information. */

var Tag = function(_a) {
    var disabled = _a.disabled,
        external = _a.external,
        href = _a.href,
        icon = _a.icon,
        label = _a.label,
        onClick = _a.onClick,
        testID = _a.testID,
        _b = _a.variant,
        variant = _b === void 0 ? "primary" : _b;
    var className = classnames(PREFIX$v, variant && PREFIX$v + "--" + variant, icon && PREFIX$v + "--icon", (onClick || href) && PREFIX$v + "--clickable"); // Consolidate Props

    var buttonAttributes = {
        className: className,
        disabled: disabled,
        onClick: onClick
    };

    var linkAttributes = __assign(__assign({}, buttonAttributes), {
        href: href,
        role: "button",
        target: external ? "_blank" : undefined
    });

    var combinedAttributes = href ? linkAttributes : buttonAttributes; // Use a div when not clickable, otherwise use a button or anchor tag

    var Element = onClick ? "button" : href ? "a" : "div";
    return /*#__PURE__*/ React__default.createElement(Element, _extends({}, combinedAttributes, {
        "data-testid": testID
    }), /*#__PURE__*/ React__default.createElement("span", {
        className: PREFIX$v + "__content"
    }, icon, label));
};

exports.Avatar = Avatar;
exports.Badge = Badge;
exports.Banner = Banner;
exports.Button = Button;
exports.Checkbox = Checkbox;
exports.CheckboxGroup = CheckboxGroup;
exports.Code = Code;
exports.CodeBlock = CodeBlock;
exports.Flex = Flex;
exports.FormFieldset = FormFieldset;
exports.FormValidation = FormValidation;
exports.Heading = Heading;
exports.Icon = Icon;
exports.ImageLoader = ImageLoader;
exports.Link = Link;
exports.Loading = Loading;
exports.Logo = Logo;
exports.Modal = Modal;
exports.Popover = Popover;
exports.ProgressBar = ProgressBar;
exports.Quote = Quote;
exports.Radio = Radio;
exports.RadioGroup = RadioGroup;
exports.RoundButton = RoundButton;
exports.Select = Select;
exports.Space = Space;
exports.Switch = Switch;
exports.Tag = Tag;
exports.Text = Text;
exports.TextArea = TextArea;
exports.TextInput = TextInput;
exports.Tooltip = Tooltip;
exports.VisuallyHidden = VisuallyHidden;
exports.logging = logging;
exports.useDirectionToPopperPlacement = useDirectionToPopperPlacement;
exports.useOnClickOutside = useOnClickOutside;
exports.useOnEscKeyDown = useOnEscKeyDown;
//# sourceMappingURL=index.js.map